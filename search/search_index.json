{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CircuitBrew","text":"<p>CircuitBrew provides a framework for building SPICE-based circuits and generating test vectors  for arbitrarily complex transistor-based circuits directly in Python.  </p> <ul> <li>Free and open-source software: ASL2 license</li> <li>Blog: http://virantha.com/category/projects/circuitbrew</li> <li>Documentation: http://virantha.github.io/circuitbrew</li> <li>Source: https://github.com/virantha/circuitbrew</li> </ul> <p>Some notable features of CircuitBrew over a schematic capture tool or a Domain Specific Language based circuit design tool:  </p> <ol> <li> <p>Built-in test vector generation: With most other tools, I end up needing to build a behavioral model in a high-level language like Python to generate test vectors.  CircuitBrew provides the hooks to build the model inline with the circuit description, and uses a built-in event simulator to generate expected vectors.</p> </li> <li> <p>Simplicity: Schematic capture for complex digital circuit design can be tedious. And learning/re-learning a circuit design DSL creates a lot of overhead, especially when you want to jump in quickly and prototype a custom circuit. Here,  subckts are just Python classes, and ports are just init args; all the power of Python is available to assemble complex digital circuits at the transistor level.</p> </li> <li> <p>Ease of maintenance: Extending a circuit design DSL, as SPICE models evolve and become more complex, becomes incredibly time-consuming, especially when the original tool authors have moved on from the code base.  Everything here is built on standard Python features, and should be easily extensible.</p> </li> </ol> <p>The examples below show SPICE files emitted for the open-source SkyWater 130nm PDK, to avoid  revealing any proprietary data, but I generally use this in my own work for advanced 7nm and smaller-node foundries.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>    $ pip install circuitbrew\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Please see the usage guide. </p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>The software is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>"},{"location":"#simple-example","title":"Simple example","text":"<p>Here's a simple inverter implemented directly in Python:</p>"},{"location":"#inverter-in-python","title":"Inverter in Python","text":"<pre><code>class Inv(Module):\ninp = InputPort()\nout = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.inp, d=vdd, s=self.out, b=vdd)\nself.ndn = Nfet(g=self.inp, d=self.out, s=gnd, b=gnd)\nself.finalize()\nclass Main(Module):\ndef build(self):\nself.inv = Inv('myinv')\nself.finalize()\n</code></pre>"},{"location":"#spice-for-a-simple-inverter","title":"SPICE for a simple inverter","text":"<p>CircuitBrew directly emits SPICE from this:</p> <pre><code>.subckt Main xmyinv inp_0 out_1 p_2 p_3 Inv\n.ends\n.subckt Inv inp out p.gnd p.vdd\nxmn0 out inp p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 p.vdd inp out p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\n.ends\nxmain Main\n</code></pre>"},{"location":"#more-complex-example-with-test-vector-generation","title":"More complex example with test vector generation","text":"<p>Here's a more complex example that generates a simulation harness with test vector generation and digital checking of outputs.  We generate random values that get fed into the inverter, and verify them on the output in the SPICE sim.  CircuitBrew contains custom Verilog-A modules that can handle driving and checking values digitally inside an analog hspice simulation.</p>"},{"location":"#python-for-simulationverification-of-an-inverter","title":"Python for simulation/verification of an Inverter","text":"<pre><code>class Inv(Module):\ninp = InputPort()\nout = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.inp, d=vdd, s=self.out, b=vdd)\nself.ndn = Nfet(g=self.inp, d=self.out, s=gnd, b=gnd)\nself.finalize()\nasync def sim(self):\nwhile True:\nval = await self.inp.recv()\nawait self.out.send(1-val)\nclass Main(Module):\ndef build(self):\nself.supply = Supply('vdd', self.sim_setup['voltage'], )\np = self.supply.p\nvdd, gnd = p.vdd, p.gnd\nself.inv = Inv('myinv', p=p)\nself.clk_gen = VerilogClock('clk', freq=750e3, enable=vdd)\nsrc_clk = self.clk_gen.clk\nself.clk_buc = VerilogClock('clk2', freq=750e3, offset='100p', enable=vdd)\nsample_clk = self.clk_buc.clk\nself.src = VerilogSrc('src', [randint(0,1) for i in range(10)], \nd=self.inv.inp, clk=src_clk, _reset=vdd)\nself.bucket = VerilogBucket(name='buc', clk=sample_clk, _reset=vdd, d=self.inv.out)\nself.finalize()\n</code></pre>"},{"location":"#generated-spice-with-test-bench","title":"Generated SPICE with test bench","text":"<pre><code>.subckt Main xbuc sample_clk p.vdd d_0 VerilogBucket_0\nxclk2 p.vdd sample_clk VerilogClock freq=750000.0 offset=100p\nxclk p.vdd src_clk VerilogClock freq=750000.0 offset=0\nxmyinv inp_1 d_0 gnd p.vdd Inv\nxsrc src_clk p.vdd inp_1 VerilogSrc_0\nxvdd gnd p.vdd Supply\n.ends\n.subckt Supply p.gnd p.vdd\nVvdd_vss p.gnd 0 0.0\nVvdd_vdd p.vdd 0 1.8\n.ends\n.subckt Inv inp out p.gnd p.vdd\nxmn0 out inp p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 p.vdd inp out p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\n.ends\n.hdl hspice_clk.va\n.hdl template_0_hspice_src.va\n.hdl template_0_hspice_bucket.va\nxmain Main\n</code></pre>"},{"location":"api/","title":"CircuitBrew API Reference","text":""},{"location":"api/#circuitbrew.circuitbrew.CircuitBrew","title":"<code>CircuitBrew</code>","text":"<p>The main class.  Performs the following functions:</p> <ul> <li>Build netlist</li> <li>Simulate and generate vectors</li> <li>Output netlist</li> </ul> Source code in <code>circuitbrew/circuitbrew.py</code> <pre><code>class CircuitBrew:\n\"\"\"\n        The main class.  Performs the following functions:\n        - Build netlist\n        - Simulate and generate vectors\n        - Output netlist\n    \"\"\"\nfile_extension = { 'hspice': 'sp', 'verilog': 'v'}\ndef __init__(self, docopt_string):\nself.flow = { 'build': 'Build netlist',\n'sim'  : 'Simulate vectors',\n'netlist': 'Output netlist',\n}\nself.docopt_string = docopt_string\ndef _get_techfile(self, process: str) -&gt; tuple[dict, str]:\n\"\"\"\n            Read the tech file from process/tech.yml and the template spice file\n            for the process.  \n            Two locations are searched:\n            1. *Built-in*: The package resource inside circuitbrew/tech/process/{process}\n            2. *Locally supplied*: The local directory {process}\n            Args:\n                process: A string like 'n7' or 'sw130', or a local directory\n            Returns:\n                (techoptions, template_file):  A dict of the tech options and the contents of the template spice file\n        \"\"\"\npth = importlib.resources.files(tech) / 'process' / process\nif not pth.exists():\npth_local = Path(process)\nassert pth_local.exists(), f'Cannot find process {process} in {pth} or {pth_local}'\npth = pth_local\nwith open(pth / 'tech.yml') as f:\ntechfile = f.read()\ntechoptions = yaml.safe_load(techfile)\ntemplate_filename = techoptions['template']\nwith open(pth / template_filename) as f:\ntemplate_file = f.read()\nreturn techoptions, template_file\ndef netlist(self):\ntech_options, template_str = self._get_techfile(self.process)\nmytemplate = Template(template_str)\ncircuit_lib = import_module(self.module)\nsim_setup = tech_options\nsim_setup['sim_type'] = self.netlist_type   # Add in whether CL option was hspice or verilog\n# Measure.sim_setup = sim_setup\n# Leaf.sim_setup = sim_setup\n# G.sim_setup = sim_setup\nModule.sim_setup = sim_setup\n#sim_setup['circuit'] = main.get_netlist('xmain')\nmain = circuit_lib.Main()\nwalker = BuildPass(main, 'xmain')\nwalker.run()\nif 'sim' in self.flow:\nwalker = SimPass(main, 'xmain')\ncurio.run(walker.run_sim, with_monitor=True)\nwalker = NetlistPass(main, 'xmain')\nwalker.run()\nlines = []\nfor module, contents in Module._modules.items():\nlines += contents\nlines += '\\n'\nsim_setup['circuit'] = '\\n'.join(lines)\nsim_setup['main_type_name'] = main.get_module_type_name()\nspice = mytemplate.render(**sim_setup)\nwith open(os.path.join(sim_setup['output_dir'], 'top.'+self.file_extension[self.netlist_type]), 'w') as f:\nf.write(spice)\nreturn spice\ndef get_options(self, argv):\n\"\"\"\n            Parse the command-line options and set the following object properties:\n            :param argv: usually just sys.argv[1:]\n            :returns: Nothing\n            :ivar debug: Enable logging debug statements\n            :ivar verbose: Enable verbose logging\n            :ivar config: Dict of the config file\n        \"\"\"\ndocstring = self.docopt_string \npadding = max([len(x) for x in self.flow.keys()]) # Find max length of flow step names for padding with white space\ndocstring = docstring % ('|'.join(self.flow), \n','.join(self.flow.keys()),\n'\\n'.join(['    '+k+' '*(padding+4-len(k))+v for k,v  in self.flow.items()]))\nargs = docopt(docstring, version=__version__)\nif args['--debug']:\nlogging.basicConfig(level=logging.DEBUG, format='%(message)s')\nelif args['--verbose']:\nlogging.basicConfig(level=logging.INFO, format='%(message)s')   \n# Load in default conf values from file if specified\n# if args['--conf']:\n#     with open(args['--conf']) as f:\n#         conf_args = yaml.load(f)\n# else:\n#     conf_args = {}\n# args = merge_args(conf_args, args)\nif args['all'] == 0:\nfor f in list(self.flow):\nif args[f] == 0: del self.flow[f]\nlogging.info(\"Doing flow steps: %s\" % (','.join(self.flow.keys())))\n#self.parameters = ordered_load(args['PARAMFILE'])\n#self.run_dir = args['--rundir']\nself.process = args['TECH']\nself.module   = args['MODULE']\nself.netlist_type = args['NETLIST_TYPE']\nself.args = args # Just save this for posterity\ndef go(self, argv):\n\"\"\"\n            #. Do something\n            #. Do something else\n        \"\"\"\n# Preliminary option parse to get the --verbose and --debug flags parsed\n# for the load_plugins method.  We will reparse args again in the get_options to get\n# the full set of arguments\nif '--verbose' in argv or '-v' in argv:\nlogging.basicConfig(level=logging.INFO, format='%(message)s')\nif '--debug' in argv or '-d' in argv:\nlogging.basicConfig(level=logging.DEBUG, format='%(message)s')\nlogger.info('Analyzing options...')\nself.get_options(argv)\nlogger.info('Setting up run...')\nself.netlist()\n</code></pre>"},{"location":"api/#circuitbrew.circuitbrew.CircuitBrew._get_techfile","title":"<code>_get_techfile(process)</code>","text":"<p>Read the tech file from process/tech.yml and the template spice file for the process.  </p> <p>Two locations are searched:</p> <ol> <li>Built-in: The package resource inside circuitbrew/tech/process/{process}</li> <li>Locally supplied: The local directory {process}</li> </ol> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>str</code> <p>A string like 'n7' or 'sw130', or a local directory</p> required <p>Returns:</p> Type Description <code>techoptions, template_file</code> <p>A dict of the tech options and the contents of the template spice file</p> Source code in <code>circuitbrew/circuitbrew.py</code> <pre><code>def _get_techfile(self, process: str) -&gt; tuple[dict, str]:\n\"\"\"\n        Read the tech file from process/tech.yml and the template spice file\n        for the process.  \n        Two locations are searched:\n        1. *Built-in*: The package resource inside circuitbrew/tech/process/{process}\n        2. *Locally supplied*: The local directory {process}\n        Args:\n            process: A string like 'n7' or 'sw130', or a local directory\n        Returns:\n            (techoptions, template_file):  A dict of the tech options and the contents of the template spice file\n    \"\"\"\npth = importlib.resources.files(tech) / 'process' / process\nif not pth.exists():\npth_local = Path(process)\nassert pth_local.exists(), f'Cannot find process {process} in {pth} or {pth_local}'\npth = pth_local\nwith open(pth / 'tech.yml') as f:\ntechfile = f.read()\ntechoptions = yaml.safe_load(techfile)\ntemplate_filename = techoptions['template']\nwith open(pth / template_filename) as f:\ntemplate_file = f.read()\nreturn techoptions, template_file\n</code></pre>"},{"location":"api/#circuitbrew.circuitbrew.CircuitBrew.get_options","title":"<code>get_options(argv)</code>","text":"<p>Parse the command-line options and set the following object properties:</p> <p>:param argv: usually just sys.argv[1:] :returns: Nothing</p> <p>:ivar debug: Enable logging debug statements :ivar verbose: Enable verbose logging :ivar config: Dict of the config file</p> Source code in <code>circuitbrew/circuitbrew.py</code> <pre><code>def get_options(self, argv):\n\"\"\"\n        Parse the command-line options and set the following object properties:\n        :param argv: usually just sys.argv[1:]\n        :returns: Nothing\n        :ivar debug: Enable logging debug statements\n        :ivar verbose: Enable verbose logging\n        :ivar config: Dict of the config file\n    \"\"\"\ndocstring = self.docopt_string \npadding = max([len(x) for x in self.flow.keys()]) # Find max length of flow step names for padding with white space\ndocstring = docstring % ('|'.join(self.flow), \n','.join(self.flow.keys()),\n'\\n'.join(['    '+k+' '*(padding+4-len(k))+v for k,v  in self.flow.items()]))\nargs = docopt(docstring, version=__version__)\nif args['--debug']:\nlogging.basicConfig(level=logging.DEBUG, format='%(message)s')\nelif args['--verbose']:\nlogging.basicConfig(level=logging.INFO, format='%(message)s')   \n# Load in default conf values from file if specified\n# if args['--conf']:\n#     with open(args['--conf']) as f:\n#         conf_args = yaml.load(f)\n# else:\n#     conf_args = {}\n# args = merge_args(conf_args, args)\nif args['all'] == 0:\nfor f in list(self.flow):\nif args[f] == 0: del self.flow[f]\nlogging.info(\"Doing flow steps: %s\" % (','.join(self.flow.keys())))\n#self.parameters = ordered_load(args['PARAMFILE'])\n#self.run_dir = args['--rundir']\nself.process = args['TECH']\nself.module   = args['MODULE']\nself.netlist_type = args['NETLIST_TYPE']\nself.args = args # Just save this for posterity\n</code></pre>"},{"location":"api/#circuitbrew.circuitbrew.CircuitBrew.go","title":"<code>go(argv)</code>","text":""},{"location":"api/#circuitbrew.circuitbrew.CircuitBrew.go--do-something","title":". Do something","text":""},{"location":"api/#circuitbrew.circuitbrew.CircuitBrew.go--do-something-else","title":". Do something else","text":"Source code in <code>circuitbrew/circuitbrew.py</code> <pre><code>def go(self, argv):\n\"\"\"\n        #. Do something\n        #. Do something else\n    \"\"\"\n# Preliminary option parse to get the --verbose and --debug flags parsed\n# for the load_plugins method.  We will reparse args again in the get_options to get\n# the full set of arguments\nif '--verbose' in argv or '-v' in argv:\nlogging.basicConfig(level=logging.INFO, format='%(message)s')\nif '--debug' in argv or '-d' in argv:\nlogging.basicConfig(level=logging.DEBUG, format='%(message)s')\nlogger.info('Analyzing options...')\nself.get_options(argv)\nlogger.info('Setting up run...')\nself.netlist()\n</code></pre>"},{"location":"api/#circuitbrew.ports.InputPort","title":"<code>InputPort</code>","text":"<p>         Bases: <code>Port</code></p> <p>Single bit Input Port</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class InputPort(Port): \n\"\"\"Single bit Input Port\n    \"\"\"\npass\n</code></pre>"},{"location":"api/#circuitbrew.ports.InputPorts","title":"<code>InputPorts</code>","text":"<p>         Bases: <code>Ports</code></p> <p>Sequence (array) of InputPort</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class InputPorts(Ports):\n\"\"\"Sequence (array) of InputPort\n    \"\"\"\nport_type = InputPort\n</code></pre>"},{"location":"api/#circuitbrew.ports.OutputPort","title":"<code>OutputPort</code>","text":"<p>         Bases: <code>Port</code></p> <p>Single bit Output Port</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class OutputPort(Port): \n\"\"\"Single bit Output Port\n    \"\"\"\npass\n</code></pre>"},{"location":"api/#circuitbrew.ports.OutputPorts","title":"<code>OutputPorts</code>","text":"<p>         Bases: <code>Ports</code></p> <p>Sequence (array) of OutputPort</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class OutputPorts(Ports):\n\"\"\"Sequence (array) of OutputPort\n    \"\"\"\nport_type = OutputPort\n</code></pre>"},{"location":"api/#circuitbrew.ports.Port","title":"<code>Port</code>","text":"<p>         Bases: <code>WithId</code></p> <p>The basic port class used to build up arrays of ports Ports, and Compound ports.</p>"},{"location":"api/#circuitbrew.ports.Port--simulation-abilities","title":"Simulation abilities","text":"<p>Has a built in queue to model transferring data from the sender to the receiver.  The recv, send, and sim async functions implement the actual data transfer.</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class Port(WithId):\n\"\"\"The basic port class used to build up arrays of ports\n       Ports, and Compound ports.\n       Simulation abilities\n       --------------------\n       Has a built in queue to model transferring data from the sender\n       to the receiver.  The recv, send, and sim async functions implement\n       the actual data transfer.\n    \"\"\"\ndef __init__(self, name=\"\", count=None):\nsuper().__init__()\nself.connections = set()\nself._q = Queue()   \nself.name = name\nif count:\nself.count = count\nlogger.debug(f'__init__ ({name}): id = {self.count}')\n# ----------------------------------------------------------------\n# Simulation related methods\n# ----------------------------------------------------------------\nasync def recv(self):\n\"\"\"Receive a value on the internal Curio queue\n           :return: received value\n        \"\"\"\nq = self._q\ntok = await q.get()\n#await q.task_done()\nlogger.info(f'Received {tok} on port {self.name}')\nreturn tok\nasync def send(self, val):\n# Copy to all listeners in the q\nfor receiver in self.connections:\nqueue = receiver._q\nlogger.info(f'Sending {val} on {self} to receiver {receiver.name}')\nawait queue.put(val)\nasync def sim(self):\nwhile True:\nval = await self.recv()\nawait self.send(val)\n# ----------------------------------------------------------------\n# Transistor stack creation using bit-wise operators\n#   e.g. port_a &amp; port_b yields a series n-fet stack \n# ----------------------------------------------------------------\ndef __invert__(self):\nlogger.debug(f'NEGATING port {self}')\nfrom .stack import Stack\nstack=Stack()\nstack.add_parallel_fet(self, negated=True)\nreturn stack\ndef __and__(self, other):\nfrom .stack import Stack\nlogger.debug(f'ANDing ports {self} with {other}')\nif isinstance(other, Stack):\nother.add_series_fet(self)\nreturn other\nelse:\nlogger.debug(f'Got {self.name} &amp; {other.name}')\nstack = Stack()\nstack.add_series_fet(self)\nstack.add_series_fet(other)\nreturn stack\ndef __or__(self, other):\nfrom .stack import Stack\nfrom .fets import Nfet\nlogger.debug(f'ORing ports {self} with {other}')\nif isinstance(other, Stack):\nother.add_parallel_fet(self)\nreturn other\nelse:\nlogger.debug(f'Got {self.name} &amp; {other.name}')\nstack = Stack()\nstack.add_parallel_fet(other)\nstack.add_parallel_fet(self)\nreturn stack\n# ----------------------------------------------------------------\n# Decorator protocol to allow these to be used in Module classes\n# as instance variables (\"block ports\") \n# ----------------------------------------------------------------\ndef __set_name__(self, cls, name):\nlogger.debug(f'{self.__class__}: setting name to {name} for port id {self.count}')\nself.name = name\ndef __get__(self, instance, cls):\nreturn self._get_or_create_port(instance)\ndef __set__(self, instance, value):\n# Create a new Port object (not a descriptor) to store it into the instance\n# if the instance does not already have it\nport = self._get_or_create_port(instance)\nport._set(value)\ndef _get_or_create_port(self, instance):\nif (port := instance.__dict__.get(self.name)):\nreturn port\nelse:\nport = type(self)(name=self.name, count=self.count)\ninstance.__dict__[self.name] = port\nreturn port\ndef _set(self, value):\nassert isinstance(value, Port), f'Trying to set {self} to non-port type {type(value)}'\nself.connections.add(value)\nvalue.connections.add(self)\ndef __str__(self):\ns = f'{self.name}:{self.__class__.__name__}({hex(id(self))})'\nif len(self.connections) &gt; 0:\nconnects = []\nfor p in self.connections:\np_str = f'{p.name}:{p.__class__.__name__}({hex(id(p))})'\nconnects.append(p_str)\n#connects = ','.join([f'{p.name}:{str(p)}' for p in self.connections if id(p)!=id(self) ])\nconnects = ','.join(connects)\nreturn f'{s} -&gt; [{connects}]'\nelse:\nreturn s\ndef get_spice(self):\n\"\"\"When building the subckt definition's port list, just return the name of this\n           port.\n        \"\"\"\nreturn self.name\ndef get_instance_spice(self, scope: \"SymbolTable\"):\n\"\"\"When a module is instanced, then we need to find the proper\n           argument name to pass in to the port.  This is done using the scope, \n           to translate this port object into the scoped variable name.\n        \"\"\"\n#assert len(self.connections) &gt; 0, f'{self} is not connected!'\nif (port_tuple := scope.get_symbol_from_scope(self)):\nport_name, port = port_tuple\nreturn port_name\nelse:\n# TODO: Convert this to an assert in production code\nreturn 'UNC'\ndef __iter__(self):\nyield self\ndef get_flattened(self, parent_scope_name=None):\nif not parent_scope_name:\nreturn {self.name: self}\nelse:\nreturn {f'{parent_scope_name}.{self.name}': self}\ndef iter_flattened(self):\nyield self\ndef is_flat(self):\nreturn True\n</code></pre>"},{"location":"api/#circuitbrew.ports.Port.get_instance_spice","title":"<code>get_instance_spice(scope)</code>","text":"<p>When a module is instanced, then we need to find the proper argument name to pass in to the port.  This is done using the scope,  to translate this port object into the scoped variable name.</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>def get_instance_spice(self, scope: \"SymbolTable\"):\n\"\"\"When a module is instanced, then we need to find the proper\n       argument name to pass in to the port.  This is done using the scope, \n       to translate this port object into the scoped variable name.\n    \"\"\"\n#assert len(self.connections) &gt; 0, f'{self} is not connected!'\nif (port_tuple := scope.get_symbol_from_scope(self)):\nport_name, port = port_tuple\nreturn port_name\nelse:\n# TODO: Convert this to an assert in production code\nreturn 'UNC'\n</code></pre>"},{"location":"api/#circuitbrew.ports.Port.get_spice","title":"<code>get_spice()</code>","text":"<p>When building the subckt definition's port list, just return the name of this port.</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>def get_spice(self):\n\"\"\"When building the subckt definition's port list, just return the name of this\n       port.\n    \"\"\"\nreturn self.name\n</code></pre>"},{"location":"api/#circuitbrew.ports.Port.recv","title":"<code>recv()</code>  <code>async</code>","text":"<p>Receive a value on the internal Curio queue</p> <p>:return: received value</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>async def recv(self):\n\"\"\"Receive a value on the internal Curio queue\n       :return: received value\n    \"\"\"\nq = self._q\ntok = await q.get()\n#await q.task_done()\nlogger.info(f'Received {tok} on port {self.name}')\nreturn tok\n</code></pre>"},{"location":"api/#circuitbrew.ports.Ports","title":"<code>Ports</code>","text":"<p>         Bases: <code>MutableSequence</code>, <code>WithId</code></p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class Ports(MutableSequence, WithId):\nport_type = Port\ndef __init__(self, **kwargs):\nsuper().__init__()\nself.ports = None\nif (count := kwargs.get('count')):\nself.count = count\nif 'items' in kwargs:\nitems = kwargs['items']\nself.width = len(items) \nself.ports = items\nif 'name' in kwargs:\nself.name = kwargs['name']\nelif 'name' in kwargs:\nassert 'width' in kwargs, f'{type(self)} construction must specify width using (width=..)'\nself.width = kwargs['width']\nself.name = kwargs['name']\n# Enough info to instantiate this object\nself.ports = [self.port_type(name=f'{self.name}[{i}]') for i in range(self.width)]\nelse:\n# Decorator only\nassert 'width' in kwargs, f'{type(self)} construction must specify width using (width=..)'\nself.width = kwargs['width']\ndef __set_name__(self, cls, name):\nlogger.debug(f'got name {name} for ')\nself.name = name\n#if not self.ports:  # In case we manually supplied the list of ports already in the constructore (items=...)\n#self.ports = [self.port_type(name=f'{self.name}[{i}]') for i in range(self.width)]\ndef _insert_into_instance(self, instance):\nif (ports := instance.__dict__.get(self.name)):\nreturn ports\nelse:\n# Check if there was parameter for the width.  If so, it will be a deferred callable that should\n# resolve at this point (because the instance has been instantiatied).\nif callable(self.width): self.width = self.width(instance)\nports = instance.__dict__[self.name] = type(self)(name=self.name, width=self.width, count=self.count)\nreturn ports\ndef _set(self, value):\nassert isinstance(value, list), f'Trying to set {self} to non-list type {type(value)}'\nfor p,v in zip(self.ports, value):\nassert isinstance(v, Port), f'Trying to set {self} to non-port type {type(value)}'\np._set(v)\ndef __get__(self, instance, cls):\nports = self._insert_into_instance(instance)\nassert ports\nreturn ports\ndef __set__(self, instance, value):\nassert len(value) == self.width\nports = self._insert_into_instance(instance)\nfor port, val in zip(ports, value):\nport._set(val)\ndef __getitem__(self, index):\nif isinstance(index, slice):\nelements = self.ports[index]\nreturn type(self)(name=self.name, items=elements)\nelse:\nreturn self.ports[index]\n#return type(self)(key=f'{self.key}[{index}]', width=1, items=[self.ports[index]])\ndef __len__(self): \nreturn self.width\ndef __setitem__(self, index, val):\nlogger.debug(f'Inside __setitem__ with {val} and index {index}')\n# Just need to set the connection\nif isinstance(index, slice):\nfor port, v in zip(self.ports[index], val):\nport._set(v)\nlogger.debug(f'\\tSetting connection {port} to {v}')\nelse:\nself.ports[index]._set(val)\ndef __delitem__(self, index):\nraise Exception\ndef insert(self, index, val):\nraise Exception\ndef get_spice(self):\ns = ' '.join([ port.get_spice() for port in self.ports])\nreturn s\ndef get_instance_spice(self, scope):\n\"\"\"scope is a symbol table of the module that is trying to instance\n           this in its body\n        \"\"\"\ns = ' '.join([ port.get_instance_spice(scope) for port in self.ports])\nreturn s\ndef get_flattened(self, parent_scope_name=None):\nport_dict = {}\nfor port in self.ports:\nif parent_scope_name: \nprefix= f'{parent_scope_name}.'\nelse:\nprefix = ''\nport_dict[f'{prefix}{port.name}'] = port\nreturn port_dict\ndef iter_flattened(self):\nyield from self.ports\n# for port in self.ports:\n#     yield from port.iter_flattened()\ndef is_flat(self):\nreturn False\nasync def recv(self):\n\"\"\" Receive a list of values on each port\n            Returns:\n                received value\n        \"\"\"\nvals = []\nfor p in self.ports:\nvals.append(await p.recv())\nlogger.info(f'Received {vals} on port {self.name}')\nreturn vals\nasync def send(self, val: list):\n\"\"\" Send list of values on list of ports\n        \"\"\"\n# Copy to all listeners in the q\nfor p, v in zip(self.ports, val):\n# Copy v to every connection in p\nawait p.send(v)\n</code></pre>"},{"location":"api/#circuitbrew.ports.Ports.get_instance_spice","title":"<code>get_instance_spice(scope)</code>","text":"<p>scope is a symbol table of the module that is trying to instance this in its body</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>def get_instance_spice(self, scope):\n\"\"\"scope is a symbol table of the module that is trying to instance\n       this in its body\n    \"\"\"\ns = ' '.join([ port.get_instance_spice(scope) for port in self.ports])\nreturn s\n</code></pre>"},{"location":"api/#circuitbrew.ports.Ports.recv","title":"<code>recv()</code>  <code>async</code>","text":"<p>Receive a list of values on each port</p> <p>Returns:</p> Type Description <p>received value</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>async def recv(self):\n\"\"\" Receive a list of values on each port\n        Returns:\n            received value\n    \"\"\"\nvals = []\nfor p in self.ports:\nvals.append(await p.recv())\nlogger.info(f'Received {vals} on port {self.name}')\nreturn vals\n</code></pre>"},{"location":"api/#circuitbrew.ports.Ports.send","title":"<code>send(val)</code>  <code>async</code>","text":"<p>Send list of values on list of ports</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>async def send(self, val: list):\n\"\"\" Send list of values on list of ports\n    \"\"\"\n# Copy to all listeners in the q\nfor p, v in zip(self.ports, val):\n# Copy v to every connection in p\nawait p.send(v)\n</code></pre>"},{"location":"api/#circuitbrew.symbols.Symbol","title":"<code>Symbol</code>","text":"<p>A class representing a symbol with hierarchical naming.</p> Source code in <code>circuitbrew/symbols.py</code> <pre><code>class Symbol:\n\"\"\"\n        A class representing a symbol with hierarchical naming.\n    \"\"\"\ndef __init__(self, name: str, port: Port, hierarchy: str = None):\n\"\"\"\n        Generate the hierarchical name of the symbol by recursively concatenating\n        parent names in the hierarchy, separated by the specified separator.\n        Args:\n            name: Symbol name\n            port: Port that is referred to by this symbol\n            hierarchy: The parent (for examplate a.a)\n        \"\"\"\nself.name = name\nself.port = port\nself.hierarchy = hierarchy\ndef get_hierarchical_name(self, separator='.'):\nif self.hierarchy:\nparent_name = self.hierarchiy.get_hiearchical_name(separator)\nreturn f'{parent_name}{separator}{self.name}'\nelse:\nreturn f'{self.name}'\ndef __repr__(self):\nreturn f'Symbol({self.name}, {self.port}, {self.hierarchy})'\ndef __lt__(self, other):\nreturn self.name &lt; other.name\n</code></pre>"},{"location":"api/#circuitbrew.symbols.Symbol.__init__","title":"<code>__init__(name, port, hierarchy=None)</code>","text":"<p>Generate the hierarchical name of the symbol by recursively concatenating parent names in the hierarchy, separated by the specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Symbol name</p> required <code>port</code> <code>Port</code> <p>Port that is referred to by this symbol</p> required <code>hierarchy</code> <code>str</code> <p>The parent (for examplate a.a)</p> <code>None</code> Source code in <code>circuitbrew/symbols.py</code> <pre><code>def __init__(self, name: str, port: Port, hierarchy: str = None):\n\"\"\"\n    Generate the hierarchical name of the symbol by recursively concatenating\n    parent names in the hierarchy, separated by the specified separator.\n    Args:\n        name: Symbol name\n        port: Port that is referred to by this symbol\n        hierarchy: The parent (for examplate a.a)\n    \"\"\"\nself.name = name\nself.port = port\nself.hierarchy = hierarchy\n</code></pre>"},{"location":"api/#circuitbrew.symbols.SymbolTable","title":"<code>SymbolTable</code>","text":"Source code in <code>circuitbrew/symbols.py</code> <pre><code>class SymbolTable:\ndef __init__(self, instance):\nself.instance = instance\n# Keep track of the local vars (typically not Ports) with:\n# 1. Forward map (name to obj)\n# 2. Reverse map (obj to name)\nself.locals = {}\nself.locals_obj_to_name = {}\nself.sub_instances = {} # Dict mapping instance name to instance object \n# instantiated in this module\nself.sub_instance_ports = {}\nself.ports = self.get_ports()\nself.params = {} # If this module needs to be parametrized\nself.tmp_id = 0  # Counter to keep track of new temp variables we create in locals\ndef _get_set_of_connections(self, port, port_name, connection_dict):\nif port.is_flat() or isinstance(port, Ports):\nparent_scope_name = ''\nelse:\nparent_scope_name = port_name\nfor atomic_port_name, atomic_port in port.get_flattened(parent_scope_name).items():\nport_sym = Symbol(atomic_port_name, atomic_port)\n# Add in the self connection\nconnection_dict[atomic_port].add(port_sym)\nfor conn_port in atomic_port.connections:\nconnection_dict[conn_port].add(port_sym)\ndef _setup_connections_lookup(self):\n\"\"\"This must be called before the netlisting step.\n           We build up a fast lookup dict for finding connections.\n           We need to flatten all ports though for the lookup.\n           And, for example, for locals, we may have multiple aliases to the same port\n           So, for example:\n               self.connection\n        \"\"\"\nself.connected = {'ports': defaultdict(set),    # dict of port obj to set of connected symbols that are ports of this instances\n'locals': defaultdict(set),\n}\nLogBlock(f'Setting up connections lookup for {self.instance} symbol table')\nwork = {'ports': self.get_ports().items(),\n'locals': self.locals.items(),\n} \nfor port_name, port in self.get_ports().items():\nself._get_set_of_connections(port, port_name, self.connected['ports'])\nfor local_name, port in self.locals.items():\nsym = Symbol(local_name, port)\n# Add in self port\nself.connected['locals'][port].add(sym)\n# Add in all connections\nfor connected_port in port.connections:\nself.connected['locals'][connected_port].add(sym)\nlogger.debug('fast ports table:')\nfor port, connected_set in self.connected['ports'].items():\nlogger.debug(f'{port} == {connected_set}')\nlogger.debug('fast locals table:')\nfor local_port, local_connected_set in self.connected['locals'].items():\nlogger.debug(f'{local_port} == {local_connected_set}')\nLogBlock(f'Setting up connections lookup for {self.instance} symbol table')\ndef get_ports(self) -&gt; dict[str, Port]:\n\"\"\"Utility method to get all the ports attached to this instance, in the\n           same order they were listed in the class definition.\n           We need to use the count attribute to sort the ports to get this ordered\n           list.\n        \"\"\"\n# [ (name, obj), ...]\nunsorted_tuple_list = inspect.getmembers(self.instance, \nlambda attr: \nisinstance(attr, Ports) or isinstance(attr, Port))\nsorted_tuple_list = sorted(unsorted_tuple_list, key=lambda p: p[1].count)\nreturn dict(sorted_tuple_list)\ndef add_local(self, local_name, local_obj):\n# Called by finalize\n# Let's keep the reverse mapping too\n# Add all the flattened ports too\nall_ports = local_obj.get_flattened(local_name)\nif len(all_ports) &gt; 1:  # Don't add in single ports (Otherwise we end up with things like clk.clk)\nfor pname, p in all_ports.items():\n#sym = Symbol(pname, p)\nsym = p\nself.locals[pname] = sym\nself.locals_obj_to_name[sym] = pname\n#sym = Symbol(local_name, local_obj)\nsym = local_obj\nself.locals[local_name] = sym\nself.locals_obj_to_name[sym] = local_name\nreturn\ndef add_sub_instance(self, inst_name, inst):\nself.sub_instances[inst_name] = inst\n# Add all the ports of the sub\n# Complication here because instt could be a list\n#self.sub_instance_ports[inst_name] = [i._sym_table.ports for i in self.iter_flattened(inst)]\nself.sub_instance_ports[inst_name] = inst._sym_table.get_ports()\n\"\"\"\n        In the below, at the Main module, myinv does not have its supply ports connected\n        So, they should be labeled as unconnected.  \n        Instead, because they are connecdted inside the Inv module, it uses those connections\n        (the shortest available).\n        Instead, what we need to do is:\n            When instancing a submodule inside a module,\n            Each port for the submodule needs to be matched to something in scope at that module\n            And only from those matches should we pick the shortest one.\n        .subckt Main a b\n        xmyinv a s d s Inv\n        .ends                               \n.subckt Inv a b p.vdd p.gnd\nxmn0 b a p.gnd UNC nch_svt_mac nfin=2 l=0.008u\nxmp0 p.vdd a b UNC pch_svt_mac nfin=2 l=0.008u\n.ends\n    \"\"\"\ndef get_symbol_from_scope(self, port):\n\"\"\"We're given a port to find in the current context (symbol table) and return\n           it's name if it exists:\n                - Search the locals (variables defined in the build)\n                - Search the module's ports\n                - Search any the ports of any submodules instanced in this module:\n                        self.inv = Inv(a, b)  # self.inv.in and self.inv.out can be used in this context\n        \"\"\"\n# Do I need a graph here to check connectivity?\n# - probably not because everything should be only 1 away\n# Check the instance ports first; this name should always take priority\n#if (sym := self.get_connected_symbol(port, self.ports)):\nif (sym := self.get_connected_symbol_fast(port, 'ports')):\nlogger.debug(f'\\t\\tFound instance port {sym}')\nreturn sym.name, sym.port\nelif (sym := self.get_connected_symbol_fast(port, 'locals')):\n#elif (sym := self.get_connected_symbol(port, self.locals)):\nlogger.debug(f'\\t\\tFound local port {sym}')\nreturn sym.name, sym.port\nelse:\n# More complicated case to search in sub_instance ports in this module\n# This is slow the first time each port is encountered, but subsequent references\n# can pull up the symbol directly from the locals (since create a new local alias\n# to refer to the subport)\nsym = self.get_connected_symbol(port, self.sub_instance_ports)\nif (sym):\n# Need to create a temp var here to access the sub port\n# because I'm not sure verilog allows a \"inst.port\" reference\ntmp_var = Port(f'{sym.name}_{self.tmp_id}')\ntmp_var._set(sym.port)\nfor conn in sym.port.connections:\ntmp_var._set(conn)\nself.add_local(tmp_var.name, tmp_var)\n# Make sure we had this new local to the fast lookup dict\nsym = Symbol(tmp_var.name, tmp_var)\nself.connected['locals'][tmp_var].add(sym)\nfor connected_port in port.connections:\nself.connected['locals'][connected_port].add(sym)\n#self._get_set_of_connections(tmp_var, tmp_var.name, self.connected['locals'])\nlogger.debug(f'\\t\\tCreated new local {tmp_var.name}={tmp_var} for {port.name}, {port}')\nself.tmp_id+=1\nreturn tmp_var.name, tmp_var\nelse:\nreturn None\ndef get_connected_symbol_fast(self, port, search_type:str) -&gt; Symbol:\nlogger.debug(f'Getting fast connected symbol in {search_type} for {port}')\nsearch_set = self.connected[search_type].get(port, None)\nif search_set:\n#return next(iter(search_set))\nreturn min(search_set)\nelse:\nreturn None\ndef get_connected_symbol(self, port, lookup_dict):\n\"\"\" Problem here is that a port may have multiple names(aliases) assorted with it\n            Symbol(a, port_a), Symbol(local_a, port_a) are two aliases to the same port \"port_a\"\n            We can't use sets for this.\n            They  \n            Need to convert this to handle the sub_instance_ports provided as a \n        \"\"\"\n# Need to make a set of port and its connections, then find intersection with p and its connections\nlogger.debug(f'Getting connected symbol for {port}')\nport_aliases = set([port]) | port.connections\nfor p_name, p in lookup_dict.items():\nlogger.debug(f'Searching {p_name}={p}')\nif isinstance(p, dict):\n# Collection of sub_instance ports\nlogger.debug('found dict')\nfor sub_port_name, sub_port in p.items():\n# Need to flatten each sub_port to check if this port is in this subinstance ports\nfor flattened in sub_port.iter_flattened():\nlogger.debug(f'\\t\\tChecking {port} against {flattened}')\nif port == flattened or flattened in port.connections:\nreturn Symbol(f'{sub_port_name}', flattened, hierarchy=p_name)\nelif p.is_flat():\np_aliases = set([p]) | p.connections\ncommon_port = port_aliases &amp; p_aliases\nif len(common_port) &gt; 0:\nreturn Symbol(p_name, p)\nelse:\ncontinue\nelif not p.is_flat():\n# Check all the flattened ports\n#sub_ports = p.get_flattened(p_name)\nsub_ports = p.get_flattened()\nsub_port_match = self.get_connected_symbol(port, sub_ports)\nif sub_port_match:\nreturn sub_port_match\nelse:\n# No match\n# Check the connected ports of each \ncontinue\nreturn None\ndef get_log_ports(self, port_dict, indent=0, msg=None):\nlines = []\ntabs = '\\t'*indent\nif msg:\nlines.append(f'{tabs}{msg} in scope:')\nelse:\ndict_name = list(self.__dict__.keys())[ list(self.__dict__.values()).index(port_dict)]\nlines.append(f'{tabs}{dict_name} in scope:')\nfound = False\nfor port_name, port in port_dict.items():\nfound = True\nlines.append(f'{tabs}\\t{port_name} = {port}')\nif not found:\nlines.append(f'{tabs}\\tNone')\nreturn '\\n'.join(lines)\n</code></pre>"},{"location":"api/#circuitbrew.symbols.SymbolTable._setup_connections_lookup","title":"<code>_setup_connections_lookup()</code>","text":"<p>This must be called before the netlisting step.</p> <p>We build up a fast lookup dict for finding connections. We need to flatten all ports though for the lookup.</p> <p>And, for example, for locals, we may have multiple aliases to the same port So, for example:     self.connection</p> Source code in <code>circuitbrew/symbols.py</code> <pre><code>def _setup_connections_lookup(self):\n\"\"\"This must be called before the netlisting step.\n       We build up a fast lookup dict for finding connections.\n       We need to flatten all ports though for the lookup.\n       And, for example, for locals, we may have multiple aliases to the same port\n       So, for example:\n           self.connection\n    \"\"\"\nself.connected = {'ports': defaultdict(set),    # dict of port obj to set of connected symbols that are ports of this instances\n'locals': defaultdict(set),\n}\nLogBlock(f'Setting up connections lookup for {self.instance} symbol table')\nwork = {'ports': self.get_ports().items(),\n'locals': self.locals.items(),\n} \nfor port_name, port in self.get_ports().items():\nself._get_set_of_connections(port, port_name, self.connected['ports'])\nfor local_name, port in self.locals.items():\nsym = Symbol(local_name, port)\n# Add in self port\nself.connected['locals'][port].add(sym)\n# Add in all connections\nfor connected_port in port.connections:\nself.connected['locals'][connected_port].add(sym)\nlogger.debug('fast ports table:')\nfor port, connected_set in self.connected['ports'].items():\nlogger.debug(f'{port} == {connected_set}')\nlogger.debug('fast locals table:')\nfor local_port, local_connected_set in self.connected['locals'].items():\nlogger.debug(f'{local_port} == {local_connected_set}')\nLogBlock(f'Setting up connections lookup for {self.instance} symbol table')\n</code></pre>"},{"location":"api/#circuitbrew.symbols.SymbolTable.get_connected_symbol","title":"<code>get_connected_symbol(port, lookup_dict)</code>","text":"<p>Problem here is that a port may have multiple names(aliases) assorted with it Symbol(a, port_a), Symbol(local_a, port_a) are two aliases to the same port \"port_a\"</p> <p>We can't use sets for this.</p> <p>They  </p> <p>Need to convert this to handle the sub_instance_ports provided as a</p> Source code in <code>circuitbrew/symbols.py</code> <pre><code>def get_connected_symbol(self, port, lookup_dict):\n\"\"\" Problem here is that a port may have multiple names(aliases) assorted with it\n        Symbol(a, port_a), Symbol(local_a, port_a) are two aliases to the same port \"port_a\"\n        We can't use sets for this.\n        They  \n        Need to convert this to handle the sub_instance_ports provided as a \n    \"\"\"\n# Need to make a set of port and its connections, then find intersection with p and its connections\nlogger.debug(f'Getting connected symbol for {port}')\nport_aliases = set([port]) | port.connections\nfor p_name, p in lookup_dict.items():\nlogger.debug(f'Searching {p_name}={p}')\nif isinstance(p, dict):\n# Collection of sub_instance ports\nlogger.debug('found dict')\nfor sub_port_name, sub_port in p.items():\n# Need to flatten each sub_port to check if this port is in this subinstance ports\nfor flattened in sub_port.iter_flattened():\nlogger.debug(f'\\t\\tChecking {port} against {flattened}')\nif port == flattened or flattened in port.connections:\nreturn Symbol(f'{sub_port_name}', flattened, hierarchy=p_name)\nelif p.is_flat():\np_aliases = set([p]) | p.connections\ncommon_port = port_aliases &amp; p_aliases\nif len(common_port) &gt; 0:\nreturn Symbol(p_name, p)\nelse:\ncontinue\nelif not p.is_flat():\n# Check all the flattened ports\n#sub_ports = p.get_flattened(p_name)\nsub_ports = p.get_flattened()\nsub_port_match = self.get_connected_symbol(port, sub_ports)\nif sub_port_match:\nreturn sub_port_match\nelse:\n# No match\n# Check the connected ports of each \ncontinue\nreturn None\n</code></pre>"},{"location":"api/#circuitbrew.symbols.SymbolTable.get_ports","title":"<code>get_ports()</code>","text":"<p>Utility method to get all the ports attached to this instance, in the same order they were listed in the class definition.</p> <p>We need to use the count attribute to sort the ports to get this ordered list.</p> Source code in <code>circuitbrew/symbols.py</code> <pre><code>def get_ports(self) -&gt; dict[str, Port]:\n\"\"\"Utility method to get all the ports attached to this instance, in the\n       same order they were listed in the class definition.\n       We need to use the count attribute to sort the ports to get this ordered\n       list.\n    \"\"\"\n# [ (name, obj), ...]\nunsorted_tuple_list = inspect.getmembers(self.instance, \nlambda attr: \nisinstance(attr, Ports) or isinstance(attr, Port))\nsorted_tuple_list = sorted(unsorted_tuple_list, key=lambda p: p[1].count)\nreturn dict(sorted_tuple_list)\n</code></pre>"},{"location":"api/#circuitbrew.symbols.SymbolTable.get_symbol_from_scope","title":"<code>get_symbol_from_scope(port)</code>","text":"<p>We're given a port to find in the current context (symbol table) and return it's name if it exists:</p> <pre><code> - Search the locals (variables defined in the build)\n - Search the module's ports\n - Search any the ports of any submodules instanced in this module:\n         self.inv = Inv(a, b)  # self.inv.in and self.inv.out can be used in this context\n</code></pre> Source code in <code>circuitbrew/symbols.py</code> <pre><code>def get_symbol_from_scope(self, port):\n\"\"\"We're given a port to find in the current context (symbol table) and return\n       it's name if it exists:\n            - Search the locals (variables defined in the build)\n            - Search the module's ports\n            - Search any the ports of any submodules instanced in this module:\n                    self.inv = Inv(a, b)  # self.inv.in and self.inv.out can be used in this context\n    \"\"\"\n# Do I need a graph here to check connectivity?\n# - probably not because everything should be only 1 away\n# Check the instance ports first; this name should always take priority\n#if (sym := self.get_connected_symbol(port, self.ports)):\nif (sym := self.get_connected_symbol_fast(port, 'ports')):\nlogger.debug(f'\\t\\tFound instance port {sym}')\nreturn sym.name, sym.port\nelif (sym := self.get_connected_symbol_fast(port, 'locals')):\n#elif (sym := self.get_connected_symbol(port, self.locals)):\nlogger.debug(f'\\t\\tFound local port {sym}')\nreturn sym.name, sym.port\nelse:\n# More complicated case to search in sub_instance ports in this module\n# This is slow the first time each port is encountered, but subsequent references\n# can pull up the symbol directly from the locals (since create a new local alias\n# to refer to the subport)\nsym = self.get_connected_symbol(port, self.sub_instance_ports)\nif (sym):\n# Need to create a temp var here to access the sub port\n# because I'm not sure verilog allows a \"inst.port\" reference\ntmp_var = Port(f'{sym.name}_{self.tmp_id}')\ntmp_var._set(sym.port)\nfor conn in sym.port.connections:\ntmp_var._set(conn)\nself.add_local(tmp_var.name, tmp_var)\n# Make sure we had this new local to the fast lookup dict\nsym = Symbol(tmp_var.name, tmp_var)\nself.connected['locals'][tmp_var].add(sym)\nfor connected_port in port.connections:\nself.connected['locals'][connected_port].add(sym)\n#self._get_set_of_connections(tmp_var, tmp_var.name, self.connected['locals'])\nlogger.debug(f'\\t\\tCreated new local {tmp_var.name}={tmp_var} for {port.name}, {port}')\nself.tmp_id+=1\nreturn tmp_var.name, tmp_var\nelse:\nreturn None\n</code></pre>"},{"location":"readme/","title":"Welcome to CircuitBrew","text":"<p>CircuitBrew provides a framework for building SPICE-based circuits and generating test vectors  for arbitrarily complex transistor-based circuits directly in Python.  </p> <ul> <li>Free and open-source software: ASL2 license</li> <li>Blog: http://virantha.com/category/projects/circuitbrew</li> <li>Documentation: http://virantha.github.io/circuitbrew</li> <li>Source: https://github.com/virantha/circuitbrew</li> </ul> <p>Some notable features of CircuitBrew over a schematic capture tool or a Domain Specific Language based circuit design tool:  </p> <ol> <li> <p>Built-in test vector generation: With most other tools, I end up needing to build a behavioral model in a high-level language like Python to generate test vectors.  CircuitBrew provides the hooks to build the model inline with the circuit description, and uses a built-in event simulator to generate expected vectors.</p> </li> <li> <p>Simplicity: Schematic capture for complex digital circuit design can be tedious. And learning/re-learning a circuit design DSL creates a lot of overhead, especially when you want to jump in quickly and prototype a custom circuit. Here,  subckts are just Python classes, and ports are just init args; all the power of Python is available to assemble complex digital circuits at the transistor level.</p> </li> <li> <p>Ease of maintenance: Extending a circuit design DSL, as SPICE models evolve and become more complex, becomes incredibly time-consuming, especially when the original tool authors have moved on from the code base.  Everything here is built on standard Python features, and should be easily extensible.</p> </li> </ol> <p>The examples below show SPICE files emitted for the open-source SkyWater 130nm PDK, to avoid  revealing any proprietary data, but I generally use this in my own work for advanced 7nm and smaller-node foundries.</p>"},{"location":"readme/#installation","title":"Installation","text":"<pre><code>    $ pip install circuitbrew\n</code></pre>"},{"location":"readme/#usage","title":"Usage","text":"<p>Please see the usage guide. </p>"},{"location":"readme/#disclaimer","title":"Disclaimer","text":"<p>The software is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>"},{"location":"readme/#simple-example","title":"Simple example","text":"<p>Here's a simple inverter implemented directly in Python:</p>"},{"location":"readme/#inverter-in-python","title":"Inverter in Python","text":"<pre><code>class Inv(Module):\ninp = InputPort()\nout = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.inp, d=vdd, s=self.out, b=vdd)\nself.ndn = Nfet(g=self.inp, d=self.out, s=gnd, b=gnd)\nself.finalize()\nclass Main(Module):\ndef build(self):\nself.inv = Inv('myinv')\nself.finalize()\n</code></pre>"},{"location":"readme/#spice-for-a-simple-inverter","title":"SPICE for a simple inverter","text":"<p>CircuitBrew directly emits SPICE from this:</p> <pre><code>.subckt Main xmyinv inp_0 out_1 p_2 p_3 Inv\n.ends\n.subckt Inv inp out p.gnd p.vdd\nxmn0 out inp p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 p.vdd inp out p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\n.ends\nxmain Main\n</code></pre>"},{"location":"readme/#more-complex-example-with-test-vector-generation","title":"More complex example with test vector generation","text":"<p>Here's a more complex example that generates a simulation harness with test vector generation and digital checking of outputs.  We generate random values that get fed into the inverter, and verify them on the output in the SPICE sim.  CircuitBrew contains custom Verilog-A modules that can handle driving and checking values digitally inside an analog hspice simulation.</p>"},{"location":"readme/#python-for-simulationverification-of-an-inverter","title":"Python for simulation/verification of an Inverter","text":"<pre><code>class Inv(Module):\ninp = InputPort()\nout = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.inp, d=vdd, s=self.out, b=vdd)\nself.ndn = Nfet(g=self.inp, d=self.out, s=gnd, b=gnd)\nself.finalize()\nasync def sim(self):\nwhile True:\nval = await self.inp.recv()\nawait self.out.send(1-val)\nclass Main(Module):\ndef build(self):\nself.supply = Supply('vdd', self.sim_setup['voltage'], )\np = self.supply.p\nvdd, gnd = p.vdd, p.gnd\nself.inv = Inv('myinv', p=p)\nself.clk_gen = VerilogClock('clk', freq=750e3, enable=vdd)\nsrc_clk = self.clk_gen.clk\nself.clk_buc = VerilogClock('clk2', freq=750e3, offset='100p', enable=vdd)\nsample_clk = self.clk_buc.clk\nself.src = VerilogSrc('src', [randint(0,1) for i in range(10)], \nd=self.inv.inp, clk=src_clk, _reset=vdd)\nself.bucket = VerilogBucket(name='buc', clk=sample_clk, _reset=vdd, d=self.inv.out)\nself.finalize()\n</code></pre>"},{"location":"readme/#generated-spice-with-test-bench","title":"Generated SPICE with test bench","text":"<pre><code>.subckt Main xbuc sample_clk p.vdd d_0 VerilogBucket_0\nxclk2 p.vdd sample_clk VerilogClock freq=750000.0 offset=100p\nxclk p.vdd src_clk VerilogClock freq=750000.0 offset=0\nxmyinv inp_1 d_0 gnd p.vdd Inv\nxsrc src_clk p.vdd inp_1 VerilogSrc_0\nxvdd gnd p.vdd Supply\n.ends\n.subckt Supply p.gnd p.vdd\nVvdd_vss p.gnd 0 0.0\nVvdd_vdd p.vdd 0 1.8\n.ends\n.subckt Inv inp out p.gnd p.vdd\nxmn0 out inp p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 p.vdd inp out p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\n.ends\n.hdl hspice_clk.va\n.hdl template_0_hspice_src.va\n.hdl template_0_hspice_bucket.va\nxmain Main\n</code></pre>"},{"location":"api/api_compound_ports/","title":"compound_ports","text":""},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.CompoundPort","title":"<code>CompoundPort</code>","text":"<p>         Bases: <code>Port</code></p> <p>Aggregate different ports into one structure (like a struct) by subclassing this.</p> <p>Examples:</p> <p>Combining data/clk into one Port instance.</p> <pre><code>class DataClk(CompoundPort):\ndin = InputPort()\ndout = OutputPort()\nclk = InputPort()\n</code></pre> <p>Attributes:</p> Name Type Description <code>sym_table</code> <code>SymbolTable</code> <p>Hold all the mappings</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>class CompoundPort(Port):\n\"\"\" Aggregate different ports into one structure (like a struct) by subclassing this.\n        Examples:\n            Combining data/clk into one Port instance.\n            ``` py\n            class DataClk(CompoundPort):\n                din = InputPort()\n                dout = OutputPort()\n                clk = InputPort()\n            ```\n        Attributes:\n            sym_table (SymbolTable): Hold all the mappings\n    \"\"\"\ndef __init__(self, name=\"\"):\n\"\"\"In general, no extra args except the name if needed\n        \"\"\"\nsuper().__init__(name)\nself.sym_table = SymbolTable(self)\ndef _insert_into_instance(self, instance):\n\"\"\" Used for the descriptor protocol for attribute access to the sub ports.\n            Returns:\n                CompoundPort: Either the lookup if it exists, or the newly created self\n        \"\"\"\n# Need to create a new CompoundPort object and create new Sub port objects to go along with it\nif (compound_port:= instance.__dict__.get(self.name)):\nreturn compound_port\nelse:\ncompound_port = type(self)(name=self.name)\nfor sub_port_name, sub_port in compound_port.sym_table.get_ports().items():\n#compound_port.__dict__[sub_port_name] = type(sub_port)(name=f'{self.name}.{sub_port_name}')\ncompound_port.__dict__[sub_port_name] = type(sub_port)(name=f'{sub_port_name}')\ninstance.__dict__[self.name] = compound_port\nreturn compound_port\ndef __get__(self, instance, cls):\nport = self._insert_into_instance(instance)\nreturn port\ndef __set__(self, instance, value):\n# This gets called when we try to assign one compound port to another\n# We need to make sure the fields match up\n#assert isinstance(value, type(self)), f'Trying to connect two compound ports of types {type(value)} and {type(self)}'\nport = self._insert_into_instance(instance)\n# Create a new CompoundPort object (not a descriptor) to store it into the instance\n# if the instance does not already have it\nfor port_name, subport in port.sym_table.get_ports().items():\nval = getattr(value, port_name)\nsubport._set(val)\ndef _set(self, value):\nassert isinstance(value, CompoundPort), f'Trying to set {self} to non-compound port type {type(value)}'\nfor port_name, subport in self.sym_table.get_ports().items():\nsubport._set(getattr(value, port_name))\ndef __set_name__(self, cls, name):\nsuper().__set_name__(cls, name)\ndef __repr__(self):\n# Get all the subports\nport_dict = self.sym_table.get_ports()\nl = [f'{n}:{p}' for n,p in port_dict.items() ]\nreturn ' '.join(l)\ndef get_spice(self):\n# Need to get all the sub ports\nports = self.sym_table.get_ports() \nports_spice = [port.get_spice() for port in ports.values()]\n#s = ' '.join([ port.get_spice() for port in ports.values()])\ns = ' '.join([f'{self.name}.{port}' for port in ports_spice])\nreturn s\ndef get_instance_spice(self, scope):\n# Need to get all the sub ports\n# TODO: Do we need to maintain the hierarchy name for the sub-ports?\nports = self.sym_table.get_ports() \ns = ' '.join([ port.get_instance_spice(scope) for port in ports.values()])\nreturn s\ndef __eq__(self, other):\nif not isinstance(other, CompoundPort):\nreturn False\nmyports = self.sym_table.get_ports()\nother_ports = set(other.sym_table.get_ports().values())\nfor port_name, port in myports.items():\nif port not in other_ports:\nreturn False\nreturn True\ndef __hash__(self):\nreturn hash(map(hash, self.sym_table.get_ports()))\ndef __iter__(self):\nmyports = self.sym_table.get_ports()\nfor portname, port in myports.items():\nyield from port\ndef get_flattened(self, parent_scope_name=None):\nport_dict = {}\nfor portname, port in self.sym_table.get_ports().items():\nsubport_dict = port.get_flattened(parent_scope_name=self.name)\nport_dict = port_dict | subport_dict\nreturn port_dict\ndef iter_flattened(self):\nfor port in self.sym_table.get_ports().values():\nyield from port.iter_flattened()\ndef is_flat(self): \nreturn False\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.CompoundPort.__init__","title":"<code>__init__(name='')</code>","text":"<p>In general, no extra args except the name if needed</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>def __init__(self, name=\"\"):\n\"\"\"In general, no extra args except the name if needed\n    \"\"\"\nsuper().__init__(name)\nself.sym_table = SymbolTable(self)\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.CompoundPort._insert_into_instance","title":"<code>_insert_into_instance(instance)</code>","text":"<p>Used for the descriptor protocol for attribute access to the sub ports.</p> <p>Returns:</p> Name Type Description <code>CompoundPort</code> <p>Either the lookup if it exists, or the newly created self</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>def _insert_into_instance(self, instance):\n\"\"\" Used for the descriptor protocol for attribute access to the sub ports.\n        Returns:\n            CompoundPort: Either the lookup if it exists, or the newly created self\n    \"\"\"\n# Need to create a new CompoundPort object and create new Sub port objects to go along with it\nif (compound_port:= instance.__dict__.get(self.name)):\nreturn compound_port\nelse:\ncompound_port = type(self)(name=self.name)\nfor sub_port_name, sub_port in compound_port.sym_table.get_ports().items():\n#compound_port.__dict__[sub_port_name] = type(sub_port)(name=f'{self.name}.{sub_port_name}')\ncompound_port.__dict__[sub_port_name] = type(sub_port)(name=f'{sub_port_name}')\ninstance.__dict__[self.name] = compound_port\nreturn compound_port\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.E1of2","title":"<code>E1of2</code>","text":"<p>         Bases: <code>CompoundPort</code></p> <p>A dual rail port with enable.</p> <p>For simulation, we will do a quick hack to make sure that we don't need to handle the data wires and enable individually.  The async queues already give us all the back-pressure behavior we need.  We will send the data value on the true rail only, and ignore the f and e rails.</p> <p>Attributes:</p> Name Type Description <code>t</code> <code>Port</code> <p>True rail</p> <code>f</code> <code>Port</code> <p>False rail</p> <code>e</code> <code>Port</code> <p>Enable (active low acknowledge)</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>class E1of2(CompoundPort):\n\"\"\" A dual rail port with enable.\n        For simulation, we will do a quick hack to make sure\n        that we don't need to handle the data wires and enable individually.  The\n        async queues already give us all the back-pressure behavior we need.  We\n        will send the data value on the true rail only, and ignore the f and e\n        rails.\n        Attributes:\n            t (Port): True rail\n            f (Port): False rail\n            e (Port): Enable (active low acknowledge)\n    \"\"\"\nt = Port()\nf = Port()\ne = Port()\n# ----------------------------------------------------------------\n# Simulation related methods for E1of2\n# ----------------------------------------------------------------\nasync def send(self, val):\n\"\"\" Just use the true rail for sending valuese for modelling\n        \"\"\"\nawait self.t.send(val)\nasync def recv(self):\n\"\"\" Just use the true rail for sending valuese for modelling\n        \"\"\"\nval = await self.t.recv()\nlogger.info(f'channel {self} received {val}')\nreturn val\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.E1of2.recv","title":"<code>recv()</code>  <code>async</code>","text":"<p>Just use the true rail for sending valuese for modelling</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>async def recv(self):\n\"\"\" Just use the true rail for sending valuese for modelling\n    \"\"\"\nval = await self.t.recv()\nlogger.info(f'channel {self} received {val}')\nreturn val\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.E1of2.send","title":"<code>send(val)</code>  <code>async</code>","text":"<p>Just use the true rail for sending valuese for modelling</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>async def send(self, val):\n\"\"\" Just use the true rail for sending valuese for modelling\n    \"\"\"\nawait self.t.send(val)\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.E1of2InputPort","title":"<code>E1of2InputPort</code>","text":"<p>         Bases: <code>E1of2</code></p> <p>Input Dual-rail port</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>class E1of2InputPort(E1of2):\n\"\"\"Input Dual-rail port\n    \"\"\"\npass\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.E1of2OutputPort","title":"<code>E1of2OutputPort</code>","text":"<p>         Bases: <code>E1of2</code></p> <p>Output Dual-rail port</p> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>class E1of2OutputPort(E1of2):\n\"\"\"Output Dual-rail port\n    \"\"\"\npass\n</code></pre>"},{"location":"api/api_compound_ports/#circuitbrew.compound_ports.SupplyPort","title":"<code>SupplyPort</code>","text":"<p>         Bases: <code>CompoundPort</code></p> <p>Use this for passing around the vdd and gnd global ports</p> <p>Attributes:</p> Name Type Description <code>vdd</code> <code>Port</code> <ul> <li>terminal</li> </ul> <code>gnd</code> <code>Port</code> <ul> <li>terminal</li> </ul> Source code in <code>circuitbrew/compound_ports.py</code> <pre><code>class SupplyPort(CompoundPort):\n\"\"\"Use this for passing around the vdd and gnd global ports\n        Attributes:\n            vdd (Port): + terminal\n            gnd (Port): - terminal    \n    \"\"\"\nvdd = Port()\ngnd = Port()\n</code></pre>"},{"location":"api/api_elements/","title":"elements","text":""},{"location":"api/api_elements/#circuitbrew.elements.ResetPulse","title":"<code>ResetPulse</code>","text":"<p>         Bases: <code>Leaf</code></p> <p>Create a single step waveform (useful for Reset signals)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.rst = ResetPulse(name='rst', node=myport, p=p) \n</code></pre> <p>This will use the settings in tech.yml for timing of step.</p> <pre><code>&gt;&gt;&gt; self.rst = ResetPulse(name='rst', slope=0.5, deassert_time=4)\n</code></pre> <p>Move step to 5n and complete step after 0.5n</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name for the voltage source subcircuit instance</p> required <p>Other Parameters:</p> Name Type Description <code>slope</code> <code>float</code> <p>0-100% time in ns</p> <code>deassert_time</code> <code>float</code> <p>When to create the step</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>Port</code> <p>Where the reset pulse is connected </p> <code>p</code> <code>   (SupplyPort</code> Source code in <code>circuitbrew/elements.py</code> <pre><code>class ResetPulse(Leaf):\n\"\"\" Create a single step waveform (useful for Reset signals)\n        Examples:\n            &gt;&gt;&gt; self.rst = ResetPulse(name='rst', node=myport, p=p) \n            This will use the settings in tech.yml for timing of step.\n            &gt;&gt;&gt; self.rst = ResetPulse(name='rst', slope=0.5, deassert_time=4)\n            Move step to 5n and complete step after 0.5n\n        Args:\n            name: Name for the voltage source subcircuit instance\n        Other Args:\n            slope (float): 0-100% time in ns\n            deassert_time (float): When to create the step\n        Attributes:\n            node (Port): Where the reset pulse is connected \n            p    (SupplyPort):  \n    \"\"\"\nnode = Port()\np = SupplyPort()\ndef __init__(self, name, **kwargs):\nsuper().__init__(name=name, **kwargs)\ndef get_instance_spice(self, scope):\nnode_str = self.node.get_instance_spice(scope)\ngnd_str = self.p.gnd.get_instance_spice(scope)\ns = []\nrsttime = self.deassert_time\ns.append(f'Vpwl{self.name} {node_str} {gnd_str} PWL (0n 0 {rsttime}n 0 {rsttime+self.slope}n {self.sim_setup[\"voltage\"]})')\nreturn 'n'.join(s)\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.Supply","title":"<code>Supply</code>","text":"<p>         Bases: <code>Module</code></p> <p>Instantiate the full supply for vdd and gnd as a sub-circuit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.vdd_supply = Supply(name='vdd', voltage=self.sim_setup['voltage'])\n    p = self.vdd_supply.p\n    vdd = p.vdd\n    gnd = p.gnd\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name for the voltage source subcircuit instance</p> required <code>voltage</code> <p>Voltage level ('1.8V', '750mV', etc)</p> required <code>measure</code> <p>Whether to measure power or not</p> <code>True</code> <p>Other Parameters:</p> Name Type Description <code>p</code> <code>SupplyPort, Optional</code> <p>The port to connect to</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class Supply(Module):\n\"\"\" Instantiate the full supply for vdd and gnd as a sub-circuit.\n        Examples:\n            &gt;&gt;&gt; self.vdd_supply = Supply(name='vdd', voltage=self.sim_setup['voltage'])\n                p = self.vdd_supply.p\n                vdd = p.vdd\n                gnd = p.gnd\n        Args:\n            name: Name for the voltage source subcircuit instance\n            voltage: Voltage level ('1.8V', '750mV', etc)\n            measure: Whether to measure power or not\n        Other Args:\n            p (SupplyPort, Optional): The port to connect to\n    \"\"\"\np = SupplyPort()\ndef __init__(self, name, voltage, measure=True, **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.voltage = voltage\nself.measure = measure\ndef build(self):\nself.vsupply =  VoltageSource(f'{self.name}_vdd', self.voltage)\nself.p.vdd = self.vsupply.node\nself.vgnd =  VoltageSource(f'{self.name}_vss', 0.0)\nself.p.gnd = self.vgnd.node\nif self.measure:\nself.msr_power = Power(voltage_source=self.vsupply)\nself.finalize()\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogBucket","title":"<code>VerilogBucket</code>","text":"<p>         Bases: <code>VerilogParametrizedModule</code></p> <p>A single-bit bucket module that sinks values on every clk edge and checks them  against the expected values.  If the user didn't specify the expected values, then the sim model method will provide the values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[int]</code> <p>sequence of values to check against</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>clk</code> <code>InputPort</code> <p>input clock signal</p> <code>_reset</code> <code>InputPort</code> <p>only starts checking when deasserted</p> <code>d</code> <code>InputPort</code> <p>input values</p> <p>Attributes:</p> Name Type Description <code>values</code> <p>the sequence of values to check against</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class VerilogBucket(VerilogParametrizedModule):\n\"\"\" A single-bit bucket module that sinks values on every clk edge and checks them \n        against the expected values.  If the user didn't specify the\n        expected values, then the sim model method will provide the\n        values.\n        Args:\n            values: sequence of values to check against\n        Other Args:\n            clk (InputPort): input clock signal\n            _reset (InputPort): only starts checking when deasserted\n            d (InputPort): input values\n        Attributes:\n            values: the sequence of values to check against\n    \"\"\"\nclk = InputPort()\n_reset = InputPort()\nd  = InputPort()\ndef __init__(self, name: str, values: list[int]=None, **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.values = values\nself.src_filename = {'hspice': 'hspice_bucket.va'}\ndef get_spice(self):\nparam_dict = {'values': self.values,\n'nvalues': len(self.values), \n}\nreturn super().get_spice(param_dict=param_dict)\nasync def sim(self):\n\"\"\" If self.values already exists, then do nothing.\n            Otherwise, receive values on d, and append them to self.values\n        \"\"\"\nif self.values: \n# No need to simulate if user already supplied the expected values\nreturn\ntry:\nlogger.info(f'Bucket {self} waiting')\nvals = []\nwhile True:\nval = await self.d.recv()\nlogger.info(f'Bucket {self} received {val}')\nvals.append(val)\nexcept curio.CancelledError:\npass # Time to end because the simulation is done and we were cancelled\nfinally:\nself.values = vals\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogBucket.sim","title":"<code>sim()</code>  <code>async</code>","text":"<p>If self.values already exists, then do nothing.</p> <p>Otherwise, receive values on d, and append them to self.values</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>async def sim(self):\n\"\"\" If self.values already exists, then do nothing.\n        Otherwise, receive values on d, and append them to self.values\n    \"\"\"\nif self.values: \n# No need to simulate if user already supplied the expected values\nreturn\ntry:\nlogger.info(f'Bucket {self} waiting')\nvals = []\nwhile True:\nval = await self.d.recv()\nlogger.info(f'Bucket {self} received {val}')\nvals.append(val)\nexcept curio.CancelledError:\npass # Time to end because the simulation is done and we were cancelled\nfinally:\nself.values = vals\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogClock","title":"<code>VerilogClock</code>","text":"<p>         Bases: <code>VerilogModule</code></p> <p>Create a clock with the specified frequency and offset</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of object</p> required <code>freq</code> <code>float</code> <p>Frequency of clock in Hz</p> required <code>offset</code> <code>float</code> <p>Start of clock waveform from 0n (ns)</p> <code>0</code> <p>Other Parameters:</p> Name Type Description <code>enable</code> <code>InputPort</code> <p>active-high enable signal     </p> <code>clk</code> <code>OutputPort</code> <p>the output clock signal</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class VerilogClock(VerilogModule):\n\"\"\" Create a clock with the specified frequency and offset\n        Args:\n            name: Name of object\n            freq: Frequency of clock in Hz\n            offset: Start of clock waveform from 0n (ns)\n        Other Args:\n            enable (InputPort): active-high enable signal     \n            clk (OutputPort): the output clock signal\n    \"\"\"\nenable = InputPort()\nclk    = OutputPort()\ndef __init__(self, name: str, freq: float, offset: float=0, **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.freq = freq\nself.offset = offset\nself.src_filename = {'hspice': 'hspice_clk.va'}\ndef get_instance_spice(self, scope):\ns = super().get_instance_spice(scope)\ns = f'{s} freq={self.freq} offset={self.offset}'\nreturn s\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogModule","title":"<code>VerilogModule</code>","text":"<p>         Bases: <code>Module</code></p> <p>Any Module class that depends on a Verilog-A/Verilog code inside a template file can subclass this.  It will automatically copy the template file to the output directory.</p> <p>If you have a subclass that needs parameters (for example, a Source module might need to inject a series of different values into the templated verilog file, thereby creating a  different verilog file each time it's instanced), then you should use the  circuitbrew.elements.VerilogParametrizedModel below.</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class VerilogModule(Module):\n\"\"\" Any Module class that depends on a Verilog-A/Verilog code inside a template file\n        can subclass this.  It will automatically copy the template file to the output directory.\n        If you have a subclass that needs parameters (for example, a Source module might need\n        to inject a series of different values into the templated verilog file, thereby creating a \n        different verilog file each time it's instanced), then you should use the \n        [circuitbrew.elements.VerilogParametrizedModel][] below.\n    \"\"\"\ndef build(self):\nself.finalize()\ndef _emit_src_file(self, src_filename: str, \nparam_dict: dict = {}, \nout_filename: str = None) -&gt; str:\n\"\"\" Call this at the end of your `get_spice` method.\n            Need to fix this to not use deprecated pkg_resources.\n            Args:\n                src_filename: The template file (Jinja)\n                param_dict: The template variables to fill in \n                out_filename: \n                    If you want to use a different name for the output template file.\n                    If you leave unspecified, then it will use the src_filename in the output directory\n            Returns:\n                out_filename (str): The output file\n        \"\"\"\nmytemplate = Template(pkg_resources.files(tech).joinpath(src_filename).read_text())\nsrcfile = mytemplate.render(**param_dict, **self.sim_setup)\nif not out_filename: out_filename=src_filename\nself._write_file(out_filename, srcfile)\nreturn out_filename\ndef _write_file(self, filename: str, contents: str):\n\"\"\" Write out the filename to the output directory in `sim_setup['output_dir']`.\n            Optionally create that directory if it doesn't exist\n        \"\"\"\noutput_dir = self.sim_setup['output_dir']\nif not os.path.isdir(output_dir):\nlogger.info(f'Creating output directory {output_dir}')\nos.makedirs(output_dir)\nwith open(os.path.join(output_dir, filename), 'w') as f:\nf.write(contents)\ndef get_spice(self, param_dict={}):\n\"\"\" You usually don't need to override this method.  You can add whatever\n            custom parameters to the param_dict in your subclass before calling its\n            super().get_spice() method.\n            The parametrized modules are a notable exception to this.\n            See [circuitbrew.elements.VerilogParametrizedModule.get_spice][]\n        \"\"\"\nsimtype = self.sim_setup['sim_type']\nsrc_filename = self.src_filename[simtype]\nparam_dict |= { 'MODULE_NAME': self.get_module_type_name(),\n}\nself._emit_src_file(src_filename, param_dict)\nl = [f'.hdl {src_filename}']\nreturn l\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogModule._emit_src_file","title":"<code>_emit_src_file(src_filename, param_dict={}, out_filename=None)</code>","text":"<p>Call this at the end of your <code>get_spice</code> method. Need to fix this to not use deprecated pkg_resources.</p> <p>Parameters:</p> Name Type Description Default <code>src_filename</code> <code>str</code> <p>The template file (Jinja)</p> required <code>param_dict</code> <code>dict</code> <p>The template variables to fill in </p> <code>{}</code> <code>out_filename</code> <code>str</code> <p>If you want to use a different name for the output template file. If you leave unspecified, then it will use the src_filename in the output directory</p> <code>None</code> <p>Returns:</p> Name Type Description <code>out_filename</code> <code>str</code> <p>The output file</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>def _emit_src_file(self, src_filename: str, \nparam_dict: dict = {}, \nout_filename: str = None) -&gt; str:\n\"\"\" Call this at the end of your `get_spice` method.\n        Need to fix this to not use deprecated pkg_resources.\n        Args:\n            src_filename: The template file (Jinja)\n            param_dict: The template variables to fill in \n            out_filename: \n                If you want to use a different name for the output template file.\n                If you leave unspecified, then it will use the src_filename in the output directory\n        Returns:\n            out_filename (str): The output file\n    \"\"\"\nmytemplate = Template(pkg_resources.files(tech).joinpath(src_filename).read_text())\nsrcfile = mytemplate.render(**param_dict, **self.sim_setup)\nif not out_filename: out_filename=src_filename\nself._write_file(out_filename, srcfile)\nreturn out_filename\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogModule._write_file","title":"<code>_write_file(filename, contents)</code>","text":"<p>Write out the filename to the output directory in <code>sim_setup['output_dir']</code>. Optionally create that directory if it doesn't exist</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>def _write_file(self, filename: str, contents: str):\n\"\"\" Write out the filename to the output directory in `sim_setup['output_dir']`.\n        Optionally create that directory if it doesn't exist\n    \"\"\"\noutput_dir = self.sim_setup['output_dir']\nif not os.path.isdir(output_dir):\nlogger.info(f'Creating output directory {output_dir}')\nos.makedirs(output_dir)\nwith open(os.path.join(output_dir, filename), 'w') as f:\nf.write(contents)\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogModule.get_spice","title":"<code>get_spice(param_dict={})</code>","text":"<p>You usually don't need to override this method.  You can add whatever custom parameters to the param_dict in your subclass before calling its super().get_spice() method.</p> <p>The parametrized modules are a notable exception to this. See circuitbrew.elements.VerilogParametrizedModule.get_spice</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>def get_spice(self, param_dict={}):\n\"\"\" You usually don't need to override this method.  You can add whatever\n        custom parameters to the param_dict in your subclass before calling its\n        super().get_spice() method.\n        The parametrized modules are a notable exception to this.\n        See [circuitbrew.elements.VerilogParametrizedModule.get_spice][]\n    \"\"\"\nsimtype = self.sim_setup['sim_type']\nsrc_filename = self.src_filename[simtype]\nparam_dict |= { 'MODULE_NAME': self.get_module_type_name(),\n}\nself._emit_src_file(src_filename, param_dict)\nl = [f'.hdl {src_filename}']\nreturn l\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogParametrizedModule","title":"<code>VerilogParametrizedModule</code>","text":"<p>         Bases: <code>ParametrizedModule</code>, <code>VerilogModule</code></p> <p>For any verilog-a/verilog module that we need to uniquify the template file.</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class VerilogParametrizedModule(ParametrizedModule, VerilogModule): \n\"\"\" For any verilog-a/verilog module that we need to uniquify the template\n        file.\n    \"\"\"\ndef get_spice(self, param_dict: dict={}) -&gt; str:\n\"\"\" Specialized version to make sure we change the output filename for\n            every instance of this class\n        \"\"\"\nsimtype = self.sim_setup['sim_type']\nsrc_filename = self.src_filename[simtype]\nparam_dict |= { 'MODULE_NAME': self.get_module_type_name(),\n}\noutput_filename = f'template_{self._id}_{src_filename}'\nself._emit_src_file(src_filename, param_dict, output_filename)\nl = [f'.hdl {output_filename}']\nreturn l\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogParametrizedModule.get_spice","title":"<code>get_spice(param_dict={})</code>","text":"<p>Specialized version to make sure we change the output filename for every instance of this class</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>def get_spice(self, param_dict: dict={}) -&gt; str:\n\"\"\" Specialized version to make sure we change the output filename for\n        every instance of this class\n    \"\"\"\nsimtype = self.sim_setup['sim_type']\nsrc_filename = self.src_filename[simtype]\nparam_dict |= { 'MODULE_NAME': self.get_module_type_name(),\n}\noutput_filename = f'template_{self._id}_{src_filename}'\nself._emit_src_file(src_filename, param_dict, output_filename)\nl = [f'.hdl {output_filename}']\nreturn l\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VerilogSrc","title":"<code>VerilogSrc</code>","text":"<p>         Bases: <code>VerilogParametrizedModule</code>, <code>SourceModule</code></p> <p>A single-bit source module that takes a list of values and outputs them on every clock edge.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[int]</code> <p>sequence of values to output</p> required <p>Other Parameters:</p> Name Type Description <code>clk</code> <code>InputPort</code> <p>input clock signal</p> <code>_reset</code> <code>InputPort</code> <p>only starts outputting when deasserted</p> <code>d</code> <code>OutputPort</code> <p>output values</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class VerilogSrc(VerilogParametrizedModule, SourceModule):\n\"\"\" A single-bit source module that takes a list of values and outputs\n        them on every clock edge.\n        Args:\n            values: sequence of values to output\n        Other Args:\n            clk (InputPort): input clock signal\n            _reset (InputPort): only starts outputting when deasserted\n            d (OutputPort): output values\n    \"\"\"\nclk = InputPort()\n_reset = InputPort()\nd  = OutputPort()\ndef __init__(self, name, values: list[int], **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.values = values\nself.src_filename = {'hspice': 'hspice_src.va'}\ndef get_spice(self):\nparam_dict = {'values': self.values,\n'nvalues': len(self.values), \n}\nreturn super().get_spice(param_dict=param_dict)\nasync def sim(self):\nfor val in self.values:\nawait self.d.send(val)\n</code></pre>"},{"location":"api/api_elements/#circuitbrew.elements.VoltageSource","title":"<code>VoltageSource</code>","text":"<p>         Bases: <code>Leaf</code></p> <p>Emits a voltage source with ref to global '0'.  If you're trying to define the system global voltage supply, then I recommend using instead circuitbrew.elements.Supply which instantiates this module and gives you access to vdd and gnd as a circuitbrew.compound_ports.SupplyPort</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the voltage source subcircuit instance</p> required <code>voltage</code> <code>str</code> <p>Voltage level ('1.8V', '750mV', etc)</p> required <code>measure</code> <code>bool</code> <p>Whether to measure power or not (not implemented)</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>node</code> <code>Port</code> <p>The node to apply the voltage to</p> Source code in <code>circuitbrew/elements.py</code> <pre><code>class VoltageSource(Leaf):\n\"\"\" Emits a voltage source with ref to global '0'.  If you're trying to define\n        the system global voltage supply, then I recommend using\n        instead [circuitbrew.elements.Supply][] which instantiates this module\n        and gives you access to vdd and gnd\n        as a [circuitbrew.compound_ports.SupplyPort][]\n        Args:\n            name: Name for the voltage source subcircuit instance\n            voltage: Voltage level ('1.8V', '750mV', etc)\n            measure: Whether to measure power or not (not implemented)\n        Other Args:\n            node (Port): The node to apply the voltage to\n    \"\"\"\nnode = Port()\ndef __init__(self, name: str, voltage: str, measure: bool =False, **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.voltage = voltage\nself.measure = measure\ndef get_instance_spice(self, scope):\n\"\"\"\n        \"\"\"\nconnected = ' '.join(self._get_instance_ports(scope))\ns = []\ns.append(f'V{self.name} {connected} 0 {self.voltage}')\nreturn '\\n'.join(s)\n</code></pre>"},{"location":"api/api_fets/","title":"fets","text":""},{"location":"api/api_fets/#circuitbrew.fets.Fet","title":"<code>Fet</code>","text":"<p>         Bases: <code>Leaf</code></p> <p>Transistor cell</p> <p>d: Drain g: Gate s: Source b: Bulk w (Optional[str]): width l (Optional[str]): length</p> Source code in <code>circuitbrew/fets.py</code> <pre><code>class Fet(Leaf):\n\"\"\" Transistor cell\n            d: Drain\n            g: Gate\n            s: Source\n            b: Bulk\n            w (Optional[str]): width\n            l (Optional[str]): length\n    \"\"\"\nd = Port()\ng = InputPort()\ns = Port()\nb = Port()\ndef get_instance_spice(self, scope):\nconnected = ' '.join(self._get_instance_ports(scope))\n# Use the parent module's fet_count for the id\ncnt = scope.instance.fet_count[self.__class__]\n#s = f'xm{self.inst_prefix}{self._id} {connected} {self.fet_type} {self.width_id}={self.w} l={self.l}'\ns = f'xm{self.inst_prefix}{cnt} {connected} {self.fet_type} {self.width_id}={self.w} l={self.l}'\nscope.instance.fet_count.update([self.__class__])\nreturn s\n</code></pre>"},{"location":"api/api_fets/#circuitbrew.fets.Nfet","title":"<code>Nfet</code>","text":"<p>         Bases: <code>Fet</code></p> <p>Nfet</p> Source code in <code>circuitbrew/fets.py</code> <pre><code>class Nfet(Fet):\n\"\"\"Nfet\n    \"\"\"\ninst_prefix = 'n'\ndef post_init(self):\nself.fet_type = getattr(self, self.vt)\ndef connect_power(self, p: SupplyPort):\n\"\"\" Called when creating stacks (production rules) to make sure\n            the bulk is connected to gnd.\n        \"\"\"\np.gnd = self.b\n</code></pre>"},{"location":"api/api_fets/#circuitbrew.fets.Nfet.connect_power","title":"<code>connect_power(p)</code>","text":"<p>Called when creating stacks (production rules) to make sure the bulk is connected to gnd.</p> Source code in <code>circuitbrew/fets.py</code> <pre><code>def connect_power(self, p: SupplyPort):\n\"\"\" Called when creating stacks (production rules) to make sure\n        the bulk is connected to gnd.\n    \"\"\"\np.gnd = self.b\n</code></pre>"},{"location":"api/api_fets/#circuitbrew.fets.Pfet","title":"<code>Pfet</code>","text":"<p>         Bases: <code>Fet</code></p> <p>Pfet</p> Source code in <code>circuitbrew/fets.py</code> <pre><code>class Pfet(Fet):\n\"\"\"Pfet\n    \"\"\"\ninst_prefix = 'p'\ndef post_init(self):\nself.fet_type = getattr(self, self.vt)\ndef connect_power(self, p:SupplyPort):\n\"\"\" Called when creating stacks (production rules) to make sure\n            the bulk is connected to vdd.\n        \"\"\"\np.vdd = self.b\n</code></pre>"},{"location":"api/api_fets/#circuitbrew.fets.Pfet.connect_power","title":"<code>connect_power(p)</code>","text":"<p>Called when creating stacks (production rules) to make sure the bulk is connected to vdd.</p> Source code in <code>circuitbrew/fets.py</code> <pre><code>def connect_power(self, p:SupplyPort):\n\"\"\" Called when creating stacks (production rules) to make sure\n        the bulk is connected to vdd.\n    \"\"\"\np.vdd = self.b\n</code></pre>"},{"location":"api/api_gates/","title":"gates","text":""},{"location":"api/api_gates/#circuitbrew.gates.Inv_x1","title":"<code>Inv_x1 = Parameterize(Inv, p_strength=1, n_strength=1, vt='svt')</code>  <code>module-attribute</code>","text":"<p>A x1 Inverter ready to instantiate</p>"},{"location":"api/api_gates/#circuitbrew.gates.Inv_x2","title":"<code>Inv_x2 = Parameterize(Inv, p_strength=2, n_strength=2, vt='svt')</code>  <code>module-attribute</code>","text":"<p>A x2 Inverter ready to instantiate</p>"},{"location":"api/api_gates/#circuitbrew.gates.Inv","title":"<code>Inv</code>","text":"<p>         Bases: <code>Module</code></p> <p>Parametrized (n/p sizing and vt choice) inverter</p> <p>Examples:</p> <p>A n/p = 2/3 standard-vt Inverter:</p> <pre><code>&gt;&gt;&gt; self.inv = Parameterize(Inv, n_strength=2, p_strength=3, vt='svt')()\n</code></pre> <p>Connecting ports:</p> <pre><code>&gt;&gt;&gt; self.inv = Parameterize(Inv, n_strength=2, p_strength=3, vt='svt')(\n                    inp=INPUT, out=OUTPUT, p=SUPPLY)\n</code></pre> <p>Multiple instances:</p> <pre><code>&gt;&gt;&gt; Inv_x4 = Parameterize(Inv, n_strength=4, p_strength=4, vt='svt')\n&gt;&gt;&gt; self.inverters = [Inv_x4() for i in range(2)] # Create two x4 inverters\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>InputPort</code> <p>Input node</p> required <code>out</code> <code>OutputPort</code> <p>Output node</p> required <code>p</code> <code>SupplyPort</code> <p>Power/gnd port</p> required Source code in <code>circuitbrew/gates.py</code> <pre><code>class Inv(Module):\n\"\"\" Parametrized (n/p sizing and vt choice) inverter\n        Examples:\n            A n/p = 2/3 standard-vt Inverter:\n            &gt;&gt;&gt; self.inv = Parameterize(Inv, n_strength=2, p_strength=3, vt='svt')()\n            Connecting ports:\n            &gt;&gt;&gt; self.inv = Parameterize(Inv, n_strength=2, p_strength=3, vt='svt')(\n                                inp=INPUT, out=OUTPUT, p=SUPPLY)\n            Multiple instances:\n            &gt;&gt;&gt; Inv_x4 = Parameterize(Inv, n_strength=4, p_strength=4, vt='svt')\n            &gt;&gt;&gt; self.inverters = [Inv_x4() for i in range(2)] # Create two x4 inverters\n        Args:\n            inp (InputPort): Input node\n            out (OutputPort): Output node\n            p (SupplyPort): Power/gnd port\n    \"\"\"\ninp = InputPort()\nout = OutputPort()\np = SupplyPort()\nn_strength : Param\np_strength : Param\nvt         : Param\ndef build(self):\n\"\"\" Two transistors \"\"\"\nself.pup = Pfet(w=self.p_strength, vt=self.vt,\ng=self.inp, d=self.p.vdd, s=self.out, b=self.p.vdd)\nself.ndn = Nfet(w=self.n_strength, vt=self.vt,\ng=self.inp, d=self.p.gnd, s=self.out, b=self.p.gnd)\nself.finalize()\nasync def sim(self):\n\"\"\" Sim method \"\"\"\nwhile True:\nval = await self.inp.recv()\nawait self.out.send(1-val)\n</code></pre>"},{"location":"api/api_gates/#circuitbrew.gates.Inv.build","title":"<code>build()</code>","text":"<p>Two transistors</p> Source code in <code>circuitbrew/gates.py</code> <pre><code>def build(self):\n\"\"\" Two transistors \"\"\"\nself.pup = Pfet(w=self.p_strength, vt=self.vt,\ng=self.inp, d=self.p.vdd, s=self.out, b=self.p.vdd)\nself.ndn = Nfet(w=self.n_strength, vt=self.vt,\ng=self.inp, d=self.p.gnd, s=self.out, b=self.p.gnd)\nself.finalize()\n</code></pre>"},{"location":"api/api_gates/#circuitbrew.gates.Inv.sim","title":"<code>sim()</code>  <code>async</code>","text":"<p>Sim method</p> Source code in <code>circuitbrew/gates.py</code> <pre><code>async def sim(self):\n\"\"\" Sim method \"\"\"\nwhile True:\nval = await self.inp.recv()\nawait self.out.send(1-val)\n</code></pre>"},{"location":"api/api_gates/#circuitbrew.gates.NorN","title":"<code>NorN</code>","text":"<p>         Bases: <code>Module</code></p> <p>Parametrized (number of inputs) NOR gate</p> <p>Examples:</p> <p>A two-input NOR</p> <pre><code>&gt;&gt;&gt; self.nor = Parameterize(NorN, N=2)()\n</code></pre> <p>Connecting ports:</p> <pre><code>&gt;&gt;&gt; self.nor = Parameterize(NorN, N=2)(\n                    a=INPUT, b=OUTPUT, p=SUPPLY)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>InputPorts</code> <p>Input nodes (parameterized)</p> required <code>b</code> <code>OutputPort</code> <p>Output node</p> required <code>p</code> <code>SupplyPort</code> <p>Power/gnd port</p> required Source code in <code>circuitbrew/gates.py</code> <pre><code>class NorN(Module):\n\"\"\" Parametrized (number of inputs) NOR gate\n        Examples:\n            A two-input NOR\n            &gt;&gt;&gt; self.nor = Parameterize(NorN, N=2)()\n            Connecting ports:\n            &gt;&gt;&gt; self.nor = Parameterize(NorN, N=2)(\n                                a=INPUT, b=OUTPUT, p=SUPPLY)\n        Args:\n            a (InputPorts): Input nodes (parameterized)\n            b (OutputPort): Output node\n            p (SupplyPort): Power/gnd port\n    \"\"\"\nN: Param\na = InputPorts(width=Param('N'))\nb = OutputPort()\np = SupplyPort()\ndef build(self):\n\"\"\" Transistor implementation \"\"\"\np = self.p\nN = self.N\npdn = self.a[0]\npup = ~self.a[0]\nfor i in range(1,N):\npdn |= self.a[i]\npup &amp;= ~self.a[i]\nself.nor = self.make_stacks(output=self.b, pdn=pdn, pup=pup, power=p)\nself.finalize()\nasync def sim(self):\n\"\"\" Sim method \"\"\"\nwhile True:\na_vals = await self.a.recv()\nb_val = not any(a_vals)\nb_val = int(b_val) # Convert bool to 0 or 1\nawait self.b.send(b_val)\n</code></pre>"},{"location":"api/api_gates/#circuitbrew.gates.NorN.build","title":"<code>build()</code>","text":"<p>Transistor implementation</p> Source code in <code>circuitbrew/gates.py</code> <pre><code>def build(self):\n\"\"\" Transistor implementation \"\"\"\np = self.p\nN = self.N\npdn = self.a[0]\npup = ~self.a[0]\nfor i in range(1,N):\npdn |= self.a[i]\npup &amp;= ~self.a[i]\nself.nor = self.make_stacks(output=self.b, pdn=pdn, pup=pup, power=p)\nself.finalize()\n</code></pre>"},{"location":"api/api_gates/#circuitbrew.gates.NorN.sim","title":"<code>sim()</code>  <code>async</code>","text":"<p>Sim method</p> Source code in <code>circuitbrew/gates.py</code> <pre><code>async def sim(self):\n\"\"\" Sim method \"\"\"\nwhile True:\na_vals = await self.a.recv()\nb_val = not any(a_vals)\nb_val = int(b_val) # Convert bool to 0 or 1\nawait self.b.send(b_val)\n</code></pre>"},{"location":"api/api_module/","title":"module","text":""},{"location":"api/api_module/#circuitbrew.module.Leaf","title":"<code>Leaf</code>","text":"<p>         Bases: <code>Module</code></p> <p>A Leaf cell has no instances attached to it. </p> <p>It will emit its own spice (for example a transistor), or emit an  measurement command.</p> Source code in <code>circuitbrew/module.py</code> <pre><code>class Leaf(Module):\n\"\"\" A Leaf cell has no instances attached to it. \n        It will emit its own spice (for example a transistor), or emit an \n        measurement command.\n    \"\"\"\ndef build(self):\n\"\"\" Finalize this without adding any instances\n        \"\"\"\nlogger.debug(f'Finalized leaf {self.name}')\nself.finalize()\ndef finalize(self): \n\"\"\"Override the Module's finalize class because we don't\n           want to capture any local variables, for example\n        \"\"\"\nself.finalize_called = True\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Leaf.build","title":"<code>build()</code>","text":"<p>Finalize this without adding any instances</p> Source code in <code>circuitbrew/module.py</code> <pre><code>def build(self):\n\"\"\" Finalize this without adding any instances\n    \"\"\"\nlogger.debug(f'Finalized leaf {self.name}')\nself.finalize()\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Leaf.finalize","title":"<code>finalize()</code>","text":"<p>Override the Module's finalize class because we don't want to capture any local variables, for example</p> Source code in <code>circuitbrew/module.py</code> <pre><code>def finalize(self): \n\"\"\"Override the Module's finalize class because we don't\n       want to capture any local variables, for example\n    \"\"\"\nself.finalize_called = True\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Module","title":"<code>Module</code>","text":"Source code in <code>circuitbrew/module.py</code> <pre><code>class Module:\nregistry = {}  # All sub classes (class name -&gt; class)\nmodule_counts = Counter()\n_modules = {}\ndef __init__(self, name='', **kwargs):\nself.finalize_called = False\nself.fet_count = Counter()\nn = self._update_count()\nif name=='':\nname = f'{self.get_module_type_name()}_inst_{n}'\nself.name = name\nself._sym_table = SymbolTable(self)\n# Connect the supplied ports if any in kwargs\nfor p_name, p in kwargs.items():\nif(my_port := self._sym_table.ports.get(p_name)):\nmy_port._set(p)\nlogger.debug('\\n-------------------------------\\n\\n')\nlogger.debug(f'Printing ports of {self.get_module_type_name()}:...')\nlogger.debug('\\n-------------------------------\\n\\n')\nlogger.debug(self._sym_table.ports)\nfor name, p in self._sym_table.ports.items():\nlogger.debug (f'{p.count} ')\nself.get_sim_setup(**kwargs)\nself.post_init()\ndef _update_count(self):\nn = Module.module_counts[self.__class__]\nself._id = n\n# Increment subclass count\nModule.module_counts.update([self.__class__])\nreturn n\ndef post_init(self): pass\ndef get_sim_setup(self, **kw: dict):\n\"\"\"Called at the end of __init__ to take any settings\n           from the tech file and apply them automatically as member variables\n           to this object.\n           If any of these settings have been overridden by the user via the\n           kwargs, then apply those instead\n           Args:\n                kw: any options you want to override during module/leaf instancing\n           Returns:\n                None\n        \"\"\"\n# Get any settings from the sim_setup dict, mapped by class name\nsetup_dict = self.sim_setup\n# Reverse MRO so we apply defaults from base class -&gt; sub classes\nbase_classes = reversed(inspect.getmro(self.__class__))\ndef _get_auto_dict(d):\n# At each dict level, we search for each base class name\nfor bc in base_classes:\nbc_name = bc.__name__\nbc_dict = d.get(bc_name, {})\nif bc_dict:\n# base class name is found, so check if there are any auto settings\nauto = bc_dict.get('auto', {})\nfor k,v in auto.items():\n# Check if user overrode with kwargs\nif k in kw:\nsetattr(self, k, kw[k])\nelse:\nsetattr(self, k, v)\n# Recurse\n_get_auto_dict(bc_dict)\n_get_auto_dict(setup_dict)\ndef iter_flattened(self, myiter, filter=lambda x: x is not None):\n\"\"\"Iterator to flatten arbitrary nested lists\"\"\"\nif isinstance(myiter, list):\nfor subitem in myiter:\nyield from self.iter_flattened(subitem, filter)\nelif filter(myiter):\nyield myiter\nelse:\nreturn \ndef get_spice(self):\nl = []\nport_list = []\nport_list = ' '.join([port.get_spice() for port in self._sym_table.ports.values()])\nl.append(f'.subckt {self.get_module_type_name()} {port_list}')\n# Now, go through all the leaf/module instances in namespace\nfor inst_name, modules in self._sym_table.sub_instances.items():\nfor module in self.iter_flattened(modules): \nl.append(module.get_instance_spice(scope=self._sym_table))\nl.append(f'.ends')\nreturn l\ndef get_instance_spice(self, scope):\nlogger.debug(f'Getting instance spice for {self.name}:{self.get_module_type_name()}')\ns = f'x{self.name} {\" \".join(self._get_instance_ports(scope))} {self.get_module_type_name()}'\nreturn s\ndef _get_instance_ports(self, scope):\nconnected = [port.get_instance_spice(scope) for port in self._sym_table.ports.values()] \nreturn connected\ndef dump_spice(self):\ns = self.get_spice()\nprint(s)\ndef is_module(self, name, obj):\n# recursively check if this object is a module\n# (lists or iterables of modules work)\nif isinstance(obj, list):\nis_list = True\nfor subobj in obj:\n_, is_module = self.is_module(name, subobj)\nreturn is_list, is_module\nreturn is_list, True\nelse:\nis_list = False\nreturn is_list, isinstance(obj, Module)\ndef finalize(self):\nlogger.debug(f'Finalizing construction of {self}')\n#previous_frame = inspect.currentframe().f_back\nprevious_frame = inspect.currentframe().f_back\n#frame_info = stack_data.FrameInfo(previous_frame)\n#print(frame_info.variables)\nmy_locals = previous_frame.f_locals\nlogger.debug (my_locals)\nfor name, obj in my_locals.items():\nlogger.debug (name)\nif isinstance(obj, Port):\nself._sym_table.add_local(name, obj)\ndel previous_frame\nlogger.debug(f'Instance attributes:')\nlogger.debug(self._sym_table.get_log_ports(self._sym_table.locals))\nlogger.debug(f'Instance attributes:')\nlogger.debug('---------')\nfor attr in dir(self):\nobj = getattr(self, attr)\nis_list, is_module = self.is_module(attr, obj)\nif is_module:\nif is_list:\nfor inst in obj:\nself._sym_table.add_sub_instance(inst.name, inst)\nelse:\nself._sym_table.add_sub_instance(attr, obj)\nlogger.debug('---------')\n# Set a flag so we can error out if the user forgot to call self.finalize()\nself.finalize_called = True\ndef __str__(self):\nreturn self.name\ndef get_module_type_name(self):\nreturn self.__class__.__name__\ndef __init_subclass__(cls, **kwargs):\ncls.registry[str(cls)] = cls\n#cls.template = kwargs\nsuper().__init_subclass__(**kwargs)\ndef make_stacks(self, output, pdn: Stack, pup: Stack, \npower: 'SupplyPort', width=None) -&gt; list['Fet']:\n\"\"\" Given two stacks (constructed manually or via logical operators on\n            Ports), construct the CMOS gate based on the pullup and pulldown\n            networks, and return a list of Fets.\n        \"\"\"\n# Connect the output node\nassert isinstance(pdn, Stack), f'Pulldown {pdn} is not a stack'\nassert isinstance(pup, Stack), f'Pullup {pup} is not a stack'\npdn.top._set(pup.bot)\nself._connect_all_to(pdn.bot, power.gnd)\nself._connect_all_to(pup.top, power.vdd)\nself._connect_all_to(pup.bot, output)\nself._connect_all_to(pdn.top, output)\nfets = []\nfets += self._connect_stack(pdn, power)\nfets += self._connect_stack(pup, power)\nif width:\nfor fet in fets:\nfet.w = width\nreturn fets\ndef _connect_all_to(self, port, connection):\nport._set(connection)\nfor node in port.connections:\nnode._set(connection)\ndef _connect_stack(self, stack, power): # returns list of fets\nfet_list = []\nstack.connect_power(power)\nfet_list = stack.fets\n# What do we do about tmp nodes?\n# Add them to locals in sym_table\nfor tmp_node in stack.tmp_nodes:\nself._sym_table.add_local(tmp_node.name, tmp_node)\nreturn fet_list\nasync def sim(self): \n# No sim method was defined in this module,\n# So, we need to propagate all values on input to their fanouts\nport_pids = []\nfor port in self._sym_table.ports.values():\npid = await curio.spawn(port.sim())\nport_pids.append(pid)\n# Wait until this module sim is terminated\ntry:\nwhile True:\nawait curio.sleep(1)\nexcept curio.CancelledError:\n# Cancel all ports\nfor port_pid in port_pids:\nlogger.info(f'Cancelling port {port_pid}')\nawait port_pid.cancel()\nraise\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Module.get_sim_setup","title":"<code>get_sim_setup(**kw)</code>","text":"<p>Called at the end of init to take any settings from the tech file and apply them automatically as member variables to this object.</p> <p>If any of these settings have been overridden by the user via the kwargs, then apply those instead</p> <p>Parameters:</p> Name Type Description Default <code>kw</code> <code>dict</code> <p>any options you want to override during module/leaf instancing</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>circuitbrew/module.py</code> <pre><code>def get_sim_setup(self, **kw: dict):\n\"\"\"Called at the end of __init__ to take any settings\n       from the tech file and apply them automatically as member variables\n       to this object.\n       If any of these settings have been overridden by the user via the\n       kwargs, then apply those instead\n       Args:\n            kw: any options you want to override during module/leaf instancing\n       Returns:\n            None\n    \"\"\"\n# Get any settings from the sim_setup dict, mapped by class name\nsetup_dict = self.sim_setup\n# Reverse MRO so we apply defaults from base class -&gt; sub classes\nbase_classes = reversed(inspect.getmro(self.__class__))\ndef _get_auto_dict(d):\n# At each dict level, we search for each base class name\nfor bc in base_classes:\nbc_name = bc.__name__\nbc_dict = d.get(bc_name, {})\nif bc_dict:\n# base class name is found, so check if there are any auto settings\nauto = bc_dict.get('auto', {})\nfor k,v in auto.items():\n# Check if user overrode with kwargs\nif k in kw:\nsetattr(self, k, kw[k])\nelse:\nsetattr(self, k, v)\n# Recurse\n_get_auto_dict(bc_dict)\n_get_auto_dict(setup_dict)\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Module.iter_flattened","title":"<code>iter_flattened(myiter, filter=lambda x: x is not None)</code>","text":"<p>Iterator to flatten arbitrary nested lists</p> Source code in <code>circuitbrew/module.py</code> <pre><code>def iter_flattened(self, myiter, filter=lambda x: x is not None):\n\"\"\"Iterator to flatten arbitrary nested lists\"\"\"\nif isinstance(myiter, list):\nfor subitem in myiter:\nyield from self.iter_flattened(subitem, filter)\nelif filter(myiter):\nyield myiter\nelse:\nreturn \n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Module.make_stacks","title":"<code>make_stacks(output, pdn, pup, power, width=None)</code>","text":"<p>Given two stacks (constructed manually or via logical operators on Ports), construct the CMOS gate based on the pullup and pulldown networks, and return a list of Fets.</p> Source code in <code>circuitbrew/module.py</code> <pre><code>def make_stacks(self, output, pdn: Stack, pup: Stack, \npower: 'SupplyPort', width=None) -&gt; list['Fet']:\n\"\"\" Given two stacks (constructed manually or via logical operators on\n        Ports), construct the CMOS gate based on the pullup and pulldown\n        networks, and return a list of Fets.\n    \"\"\"\n# Connect the output node\nassert isinstance(pdn, Stack), f'Pulldown {pdn} is not a stack'\nassert isinstance(pup, Stack), f'Pullup {pup} is not a stack'\npdn.top._set(pup.bot)\nself._connect_all_to(pdn.bot, power.gnd)\nself._connect_all_to(pup.top, power.vdd)\nself._connect_all_to(pup.bot, output)\nself._connect_all_to(pdn.top, output)\nfets = []\nfets += self._connect_stack(pdn, power)\nfets += self._connect_stack(pup, power)\nif width:\nfor fet in fets:\nfet.w = width\nreturn fets\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Param","title":"<code>Param(name)</code>","text":"<p>Returns a new function that returns the instance variable \"name\" of  the specified instance</p> Source code in <code>circuitbrew/module.py</code> <pre><code>def Param(name):\n\"\"\"Returns a new function that returns the instance variable \"name\" of \n       the specified instance\n    \"\"\"\ndef lookup(self):\nv = getattr(self, name)\nreturn v\nreturn lookup\n</code></pre>"},{"location":"api/api_module/#circuitbrew.module.Parameterize","title":"<code>Parameterize(cls, **kwargs)</code>","text":"<p>Given Parameterize(cls, N=3, P=4),  it will return a new subclass of cls that has an init that sets instance vars N and P</p> <p>e.g Parameterize(cls, N=3, P=4) is effectively returning the following:</p> <pre><code>Class subcls_N_3_P_4(cls):\n    def __init__(self, *args, **kwargs):\n        self.N = 3\n        self.P = 4\n        cls.__init__(self, *args, **kwargs)\n</code></pre> Source code in <code>circuitbrew/module.py</code> <pre><code>def Parameterize(cls, **kwargs):\n\"\"\"Given Parameterize(cls, N=3, P=4), \n        it will return a new subclass of cls that has an __init__\n        that sets instance vars N and P\n        e.g Parameterize(cls, N=3, P=4) is effectively returning the following:\n            Class subcls_N_3_P_4(cls):\n                def __init__(self, *args, **kwargs):\n                    self.N = 3\n                    self.P = 4\n                    cls.__init__(self, *args, **kwargs)\n    \"\"\"\n# Check to make sure every param in kwargs was defined as\n# a class annotation of type Param. \nparams = []\ncls_annotations = cls.__annotations__\nfor name, val in kwargs.items():\nassert name in cls_annotations,\\\n                f'{name} is not defined as a parameter type annotation in {cls}'\nassert cls_annotations[name] is Param, \\\n                f'Annotation for {name} must be of type Param in {cls} to use as a parameter'\nparams.append(f'{name}_{val}')\nparams_to_str = '_'.join(params)\n#params_to_str = '_'.join([f'{name}_{val}' for name, val in kwargs.items()])\ndef init_fn(self, *a, **kw):\nfor name, val in kwargs.items():\nsetattr(self, name, val)\ncls.__init__(self, *a, **kw)\n#print (cls.__annotations__)\n#sys.exit(0)\nparameterized_class = type(f'{cls.__name__}_{params_to_str}', (cls,), \n{ '__init__': init_fn })\nreturn parameterized_class\n</code></pre>"},{"location":"api/api_ports/","title":"ports","text":""},{"location":"api/api_ports/#circuitbrew.ports.InputPort","title":"<code>InputPort</code>","text":"<p>         Bases: <code>Port</code></p> <p>Single bit Input Port</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class InputPort(Port): \n\"\"\"Single bit Input Port\n    \"\"\"\npass\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.InputPorts","title":"<code>InputPorts</code>","text":"<p>         Bases: <code>Ports</code></p> <p>Sequence (array) of InputPort</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class InputPorts(Ports):\n\"\"\"Sequence (array) of InputPort\n    \"\"\"\nport_type = InputPort\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.OutputPort","title":"<code>OutputPort</code>","text":"<p>         Bases: <code>Port</code></p> <p>Single bit Output Port</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class OutputPort(Port): \n\"\"\"Single bit Output Port\n    \"\"\"\npass\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.OutputPorts","title":"<code>OutputPorts</code>","text":"<p>         Bases: <code>Ports</code></p> <p>Sequence (array) of OutputPort</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class OutputPorts(Ports):\n\"\"\"Sequence (array) of OutputPort\n    \"\"\"\nport_type = OutputPort\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Port","title":"<code>Port</code>","text":"<p>         Bases: <code>WithId</code></p> <p>The basic port class used to build up arrays of ports Ports, and Compound ports.</p>"},{"location":"api/api_ports/#circuitbrew.ports.Port--simulation-abilities","title":"Simulation abilities","text":"<p>Has a built in queue to model transferring data from the sender to the receiver.  The recv, send, and sim async functions implement the actual data transfer.</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class Port(WithId):\n\"\"\"The basic port class used to build up arrays of ports\n       Ports, and Compound ports.\n       Simulation abilities\n       --------------------\n       Has a built in queue to model transferring data from the sender\n       to the receiver.  The recv, send, and sim async functions implement\n       the actual data transfer.\n    \"\"\"\ndef __init__(self, name=\"\", count=None):\nsuper().__init__()\nself.connections = set()\nself._q = Queue()   \nself.name = name\nif count:\nself.count = count\nlogger.debug(f'__init__ ({name}): id = {self.count}')\n# ----------------------------------------------------------------\n# Simulation related methods\n# ----------------------------------------------------------------\nasync def recv(self):\n\"\"\"Receive a value on the internal Curio queue\n           :return: received value\n        \"\"\"\nq = self._q\ntok = await q.get()\n#await q.task_done()\nlogger.info(f'Received {tok} on port {self.name}')\nreturn tok\nasync def send(self, val):\n# Copy to all listeners in the q\nfor receiver in self.connections:\nqueue = receiver._q\nlogger.info(f'Sending {val} on {self} to receiver {receiver.name}')\nawait queue.put(val)\nasync def sim(self):\nwhile True:\nval = await self.recv()\nawait self.send(val)\n# ----------------------------------------------------------------\n# Transistor stack creation using bit-wise operators\n#   e.g. port_a &amp; port_b yields a series n-fet stack \n# ----------------------------------------------------------------\ndef __invert__(self):\nlogger.debug(f'NEGATING port {self}')\nfrom .stack import Stack\nstack=Stack()\nstack.add_parallel_fet(self, negated=True)\nreturn stack\ndef __and__(self, other):\nfrom .stack import Stack\nlogger.debug(f'ANDing ports {self} with {other}')\nif isinstance(other, Stack):\nother.add_series_fet(self)\nreturn other\nelse:\nlogger.debug(f'Got {self.name} &amp; {other.name}')\nstack = Stack()\nstack.add_series_fet(self)\nstack.add_series_fet(other)\nreturn stack\ndef __or__(self, other):\nfrom .stack import Stack\nfrom .fets import Nfet\nlogger.debug(f'ORing ports {self} with {other}')\nif isinstance(other, Stack):\nother.add_parallel_fet(self)\nreturn other\nelse:\nlogger.debug(f'Got {self.name} &amp; {other.name}')\nstack = Stack()\nstack.add_parallel_fet(other)\nstack.add_parallel_fet(self)\nreturn stack\n# ----------------------------------------------------------------\n# Decorator protocol to allow these to be used in Module classes\n# as instance variables (\"block ports\") \n# ----------------------------------------------------------------\ndef __set_name__(self, cls, name):\nlogger.debug(f'{self.__class__}: setting name to {name} for port id {self.count}')\nself.name = name\ndef __get__(self, instance, cls):\nreturn self._get_or_create_port(instance)\ndef __set__(self, instance, value):\n# Create a new Port object (not a descriptor) to store it into the instance\n# if the instance does not already have it\nport = self._get_or_create_port(instance)\nport._set(value)\ndef _get_or_create_port(self, instance):\nif (port := instance.__dict__.get(self.name)):\nreturn port\nelse:\nport = type(self)(name=self.name, count=self.count)\ninstance.__dict__[self.name] = port\nreturn port\ndef _set(self, value):\nassert isinstance(value, Port), f'Trying to set {self} to non-port type {type(value)}'\nself.connections.add(value)\nvalue.connections.add(self)\ndef __str__(self):\ns = f'{self.name}:{self.__class__.__name__}({hex(id(self))})'\nif len(self.connections) &gt; 0:\nconnects = []\nfor p in self.connections:\np_str = f'{p.name}:{p.__class__.__name__}({hex(id(p))})'\nconnects.append(p_str)\n#connects = ','.join([f'{p.name}:{str(p)}' for p in self.connections if id(p)!=id(self) ])\nconnects = ','.join(connects)\nreturn f'{s} -&gt; [{connects}]'\nelse:\nreturn s\ndef get_spice(self):\n\"\"\"When building the subckt definition's port list, just return the name of this\n           port.\n        \"\"\"\nreturn self.name\ndef get_instance_spice(self, scope: \"SymbolTable\"):\n\"\"\"When a module is instanced, then we need to find the proper\n           argument name to pass in to the port.  This is done using the scope, \n           to translate this port object into the scoped variable name.\n        \"\"\"\n#assert len(self.connections) &gt; 0, f'{self} is not connected!'\nif (port_tuple := scope.get_symbol_from_scope(self)):\nport_name, port = port_tuple\nreturn port_name\nelse:\n# TODO: Convert this to an assert in production code\nreturn 'UNC'\ndef __iter__(self):\nyield self\ndef get_flattened(self, parent_scope_name=None):\nif not parent_scope_name:\nreturn {self.name: self}\nelse:\nreturn {f'{parent_scope_name}.{self.name}': self}\ndef iter_flattened(self):\nyield self\ndef is_flat(self):\nreturn True\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Port.get_instance_spice","title":"<code>get_instance_spice(scope)</code>","text":"<p>When a module is instanced, then we need to find the proper argument name to pass in to the port.  This is done using the scope,  to translate this port object into the scoped variable name.</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>def get_instance_spice(self, scope: \"SymbolTable\"):\n\"\"\"When a module is instanced, then we need to find the proper\n       argument name to pass in to the port.  This is done using the scope, \n       to translate this port object into the scoped variable name.\n    \"\"\"\n#assert len(self.connections) &gt; 0, f'{self} is not connected!'\nif (port_tuple := scope.get_symbol_from_scope(self)):\nport_name, port = port_tuple\nreturn port_name\nelse:\n# TODO: Convert this to an assert in production code\nreturn 'UNC'\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Port.get_spice","title":"<code>get_spice()</code>","text":"<p>When building the subckt definition's port list, just return the name of this port.</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>def get_spice(self):\n\"\"\"When building the subckt definition's port list, just return the name of this\n       port.\n    \"\"\"\nreturn self.name\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Port.recv","title":"<code>recv()</code>  <code>async</code>","text":"<p>Receive a value on the internal Curio queue</p> <p>:return: received value</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>async def recv(self):\n\"\"\"Receive a value on the internal Curio queue\n       :return: received value\n    \"\"\"\nq = self._q\ntok = await q.get()\n#await q.task_done()\nlogger.info(f'Received {tok} on port {self.name}')\nreturn tok\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Ports","title":"<code>Ports</code>","text":"<p>         Bases: <code>MutableSequence</code>, <code>WithId</code></p> Source code in <code>circuitbrew/ports.py</code> <pre><code>class Ports(MutableSequence, WithId):\nport_type = Port\ndef __init__(self, **kwargs):\nsuper().__init__()\nself.ports = None\nif (count := kwargs.get('count')):\nself.count = count\nif 'items' in kwargs:\nitems = kwargs['items']\nself.width = len(items) \nself.ports = items\nif 'name' in kwargs:\nself.name = kwargs['name']\nelif 'name' in kwargs:\nassert 'width' in kwargs, f'{type(self)} construction must specify width using (width=..)'\nself.width = kwargs['width']\nself.name = kwargs['name']\n# Enough info to instantiate this object\nself.ports = [self.port_type(name=f'{self.name}[{i}]') for i in range(self.width)]\nelse:\n# Decorator only\nassert 'width' in kwargs, f'{type(self)} construction must specify width using (width=..)'\nself.width = kwargs['width']\ndef __set_name__(self, cls, name):\nlogger.debug(f'got name {name} for ')\nself.name = name\n#if not self.ports:  # In case we manually supplied the list of ports already in the constructore (items=...)\n#self.ports = [self.port_type(name=f'{self.name}[{i}]') for i in range(self.width)]\ndef _insert_into_instance(self, instance):\nif (ports := instance.__dict__.get(self.name)):\nreturn ports\nelse:\n# Check if there was parameter for the width.  If so, it will be a deferred callable that should\n# resolve at this point (because the instance has been instantiatied).\nif callable(self.width): self.width = self.width(instance)\nports = instance.__dict__[self.name] = type(self)(name=self.name, width=self.width, count=self.count)\nreturn ports\ndef _set(self, value):\nassert isinstance(value, list), f'Trying to set {self} to non-list type {type(value)}'\nfor p,v in zip(self.ports, value):\nassert isinstance(v, Port), f'Trying to set {self} to non-port type {type(value)}'\np._set(v)\ndef __get__(self, instance, cls):\nports = self._insert_into_instance(instance)\nassert ports\nreturn ports\ndef __set__(self, instance, value):\nassert len(value) == self.width\nports = self._insert_into_instance(instance)\nfor port, val in zip(ports, value):\nport._set(val)\ndef __getitem__(self, index):\nif isinstance(index, slice):\nelements = self.ports[index]\nreturn type(self)(name=self.name, items=elements)\nelse:\nreturn self.ports[index]\n#return type(self)(key=f'{self.key}[{index}]', width=1, items=[self.ports[index]])\ndef __len__(self): \nreturn self.width\ndef __setitem__(self, index, val):\nlogger.debug(f'Inside __setitem__ with {val} and index {index}')\n# Just need to set the connection\nif isinstance(index, slice):\nfor port, v in zip(self.ports[index], val):\nport._set(v)\nlogger.debug(f'\\tSetting connection {port} to {v}')\nelse:\nself.ports[index]._set(val)\ndef __delitem__(self, index):\nraise Exception\ndef insert(self, index, val):\nraise Exception\ndef get_spice(self):\ns = ' '.join([ port.get_spice() for port in self.ports])\nreturn s\ndef get_instance_spice(self, scope):\n\"\"\"scope is a symbol table of the module that is trying to instance\n           this in its body\n        \"\"\"\ns = ' '.join([ port.get_instance_spice(scope) for port in self.ports])\nreturn s\ndef get_flattened(self, parent_scope_name=None):\nport_dict = {}\nfor port in self.ports:\nif parent_scope_name: \nprefix= f'{parent_scope_name}.'\nelse:\nprefix = ''\nport_dict[f'{prefix}{port.name}'] = port\nreturn port_dict\ndef iter_flattened(self):\nyield from self.ports\n# for port in self.ports:\n#     yield from port.iter_flattened()\ndef is_flat(self):\nreturn False\nasync def recv(self):\n\"\"\" Receive a list of values on each port\n            Returns:\n                received value\n        \"\"\"\nvals = []\nfor p in self.ports:\nvals.append(await p.recv())\nlogger.info(f'Received {vals} on port {self.name}')\nreturn vals\nasync def send(self, val: list):\n\"\"\" Send list of values on list of ports\n        \"\"\"\n# Copy to all listeners in the q\nfor p, v in zip(self.ports, val):\n# Copy v to every connection in p\nawait p.send(v)\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Ports.get_instance_spice","title":"<code>get_instance_spice(scope)</code>","text":"<p>scope is a symbol table of the module that is trying to instance this in its body</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>def get_instance_spice(self, scope):\n\"\"\"scope is a symbol table of the module that is trying to instance\n       this in its body\n    \"\"\"\ns = ' '.join([ port.get_instance_spice(scope) for port in self.ports])\nreturn s\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Ports.recv","title":"<code>recv()</code>  <code>async</code>","text":"<p>Receive a list of values on each port</p> <p>Returns:</p> Type Description <p>received value</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>async def recv(self):\n\"\"\" Receive a list of values on each port\n        Returns:\n            received value\n    \"\"\"\nvals = []\nfor p in self.ports:\nvals.append(await p.recv())\nlogger.info(f'Received {vals} on port {self.name}')\nreturn vals\n</code></pre>"},{"location":"api/api_ports/#circuitbrew.ports.Ports.send","title":"<code>send(val)</code>  <code>async</code>","text":"<p>Send list of values on list of ports</p> Source code in <code>circuitbrew/ports.py</code> <pre><code>async def send(self, val: list):\n\"\"\" Send list of values on list of ports\n    \"\"\"\n# Copy to all listeners in the q\nfor p, v in zip(self.ports, val):\n# Copy v to every connection in p\nawait p.send(v)\n</code></pre>"},{"location":"api/api_qdi/","title":"qdi","text":""},{"location":"api/api_qdi/#circuitbrew.qdi.Celement2","title":"<code>Celement2</code>","text":"<p>         Bases: <code>Module</code></p> <p>A two-input Muller C-element</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>class Celement2(Module):\n\"\"\" A two-input Muller C-element\n    \"\"\"\ni = InputPorts(width=2)\no = OutputPort()\np = SupplyPort()\ndef build(self):\n\"\"\" build method\n        \"\"\"\np = self.p\n# Let's constnnruct this using combination feedback\npdn = self.i[0] &amp; self.i[1]\npup = ~self.i[0] &amp; ~self.i[1]\nself.inv = Inv(out = self.o, p = p)\n_o = self.inv.inp\ncf_pdn = self.o &amp; (self.i[0] | self.i[1])\ncf_pup = ~self.o &amp; (~self.i[0] | ~self.i[1])\nself.celem = self.make_stacks(output=_o, pdn=pdn, pup=pup, power=p)\nself.cf    = self.make_stacks(output=_o, pdn=cf_pdn, pup=cf_pup, power=p)\nself.finalize()\nasync def sim(self):\n\"\"\" Sim method\n        \"\"\"\nself.current_val = 0\nwhile True:\n#val = await self.i[0].recv()\nval = []\nfor i in range(2):\nval.append(await self.i[i].recv())\nif val[0] == val[1]:\nself.current_val = val[0]\nawait self.out.send(self.current_val)\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.Celement2.build","title":"<code>build()</code>","text":"<p>build method</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>def build(self):\n\"\"\" build method\n    \"\"\"\np = self.p\n# Let's constnnruct this using combination feedback\npdn = self.i[0] &amp; self.i[1]\npup = ~self.i[0] &amp; ~self.i[1]\nself.inv = Inv(out = self.o, p = p)\n_o = self.inv.inp\ncf_pdn = self.o &amp; (self.i[0] | self.i[1])\ncf_pup = ~self.o &amp; (~self.i[0] | ~self.i[1])\nself.celem = self.make_stacks(output=_o, pdn=pdn, pup=pup, power=p)\nself.cf    = self.make_stacks(output=_o, pdn=cf_pdn, pup=cf_pup, power=p)\nself.finalize()\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.Celement2.sim","title":"<code>sim()</code>  <code>async</code>","text":"<p>Sim method</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>async def sim(self):\n\"\"\" Sim method\n    \"\"\"\nself.current_val = 0\nwhile True:\n#val = await self.i[0].recv()\nval = []\nfor i in range(2):\nval.append(await self.i[i].recv())\nif val[0] == val[1]:\nself.current_val = val[0]\nawait self.out.send(self.current_val)\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.VerilogBucketE1of2","title":"<code>VerilogBucketE1of2</code>","text":"<p>         Bases: <code>VerilogParametrizedModule</code></p> <p>Dual-rail with enable (E1of2) output sink/verification for 4-phase QDI circuits</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>class VerilogBucketE1of2(VerilogParametrizedModule):\n\"\"\" Dual-rail with enable (E1of2) output sink/verification for 4-phase QDI circuits\n    \"\"\"\n_pReset = InputPort()\n_sReset = InputPort()\nl = E1of2InputPort()\ndef __init__(self, name, values=None, **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.values = values\nself.src_filename = {'hspice': 'hspice_bucket_1of2.va'}\ndef get_spice(self):\nsimtype = self.sim_setup['sim_type']\nsrc_filename = self.src_filename[simtype]\nparam_dict = {'values': self.values,\n'nvalues': len(self.values), \n'MODULE_NAME': self.get_module_type_name(),\n}\noutput_filename = f'template_{self._id}_{src_filename}'\nself._emit_src_file(src_filename, param_dict, output_filename)\nl = [f'.hdl {output_filename}']\nreturn l\nasync def sim(self):\n\"\"\" Sim method \"\"\"\nif self.values:\nreturn # No need to sim as user supplied values\ntry:\nlogger.info(f'Bucket_1of2 {self} waiting')\nvals = []\nwhile True:\nval = await self.l.recv()\nlogger.info(f'Bucket_1of2 {self} received {val}')\nvals.append(val)\nexcept curio.CancelledError:\npass # Time to end because the simulation is done and we were cancelled\nfinally:\n# Save the check values for writing to a file\nself.values = vals\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.VerilogBucketE1of2.sim","title":"<code>sim()</code>  <code>async</code>","text":"<p>Sim method</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>async def sim(self):\n\"\"\" Sim method \"\"\"\nif self.values:\nreturn # No need to sim as user supplied values\ntry:\nlogger.info(f'Bucket_1of2 {self} waiting')\nvals = []\nwhile True:\nval = await self.l.recv()\nlogger.info(f'Bucket_1of2 {self} received {val}')\nvals.append(val)\nexcept curio.CancelledError:\npass # Time to end because the simulation is done and we were cancelled\nfinally:\n# Save the check values for writing to a file\nself.values = vals\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.VerilogSrcE1of2","title":"<code>VerilogSrcE1of2</code>","text":"<p>         Bases: <code>VerilogParametrizedModule</code>, <code>SourceModule</code></p> <p>Dual-rail with enable (E1of2) input source for 4-phase QDI circuits</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>class VerilogSrcE1of2(VerilogParametrizedModule, SourceModule):\n\"\"\" Dual-rail with enable (E1of2) input source for 4-phase QDI circuits\n    \"\"\"\n_pReset = InputPort()\n_sReset = InputPort()\nl = E1of2OutputPort()\ndef __init__(self, name, values, **kwargs):\nsuper().__init__(name=name, **kwargs)\nself.values = values\nself.src_filename = {'hspice': 'hspice_src_1of2.va'}\ndef get_spice(self):\nsimtype = self.sim_setup['sim_type']\nsrc_filename = self.src_filename[simtype]\nparam_dict = {'values': self.values,\n'nvalues': len(self.values), \n'MODULE_NAME': self.get_module_type_name(),\n}\noutput_filename = f'template_{self._id}_{src_filename}'\nself._emit_src_file(src_filename, param_dict, output_filename)\nl = [f'.hdl {output_filename}']\nreturn l\nasync def sim(self):\nfor val in self.values:\nawait self.l.send(val)\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.Wchb","title":"<code>Wchb</code>","text":"<p>         Bases: <code>Module</code></p> <p>A QDI weak-conditioned-half-buffer using 4-phase 1-bit data</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>class Wchb(Module):\n\"\"\" A QDI weak-conditioned-half-buffer using 4-phase 1-bit data\n    \"\"\"\nl = E1of2InputPort()\nr = E1of2OutputPort()\n_pReset = InputPort()\np = SupplyPort()\ndef build(self):\n\"\"\" Build method \"\"\"\nself.c2_t = Celement2(i=[self.l.t, self.r.e], o = self.r.t, p=self.p)\nself.c2_f = Celement2(i=[self.l.f, self.r.e], o = self.r.f, p=self.p)\nself.inv_mypreset = Inv(inp=self._pReset, p=self.p)\nmypreset = self.inv_mypreset.out\nself.nor = Parameterize(NorN, N=3)(a=[self.r.t, self.r.f, mypreset], \nb=self.l.e, p=self.p)\nself.finalize()\nasync def sim(self):\n\"\"\" Sim method \"\"\"\nwhile True:\nlogger.debug(f'{self} Waiting to receive')\nval = await self.l.recv()\nlogger.debug(f'{self} received {val}')\nawait self.r.send(val)\nlogger.debug(f'{self} sent {val}')\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.Wchb.build","title":"<code>build()</code>","text":"<p>Build method</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>def build(self):\n\"\"\" Build method \"\"\"\nself.c2_t = Celement2(i=[self.l.t, self.r.e], o = self.r.t, p=self.p)\nself.c2_f = Celement2(i=[self.l.f, self.r.e], o = self.r.f, p=self.p)\nself.inv_mypreset = Inv(inp=self._pReset, p=self.p)\nmypreset = self.inv_mypreset.out\nself.nor = Parameterize(NorN, N=3)(a=[self.r.t, self.r.f, mypreset], \nb=self.l.e, p=self.p)\nself.finalize()\n</code></pre>"},{"location":"api/api_qdi/#circuitbrew.qdi.Wchb.sim","title":"<code>sim()</code>  <code>async</code>","text":"<p>Sim method</p> Source code in <code>circuitbrew/qdi.py</code> <pre><code>async def sim(self):\n\"\"\" Sim method \"\"\"\nwhile True:\nlogger.debug(f'{self} Waiting to receive')\nval = await self.l.recv()\nlogger.debug(f'{self} received {val}')\nawait self.r.send(val)\nlogger.debug(f'{self} sent {val}')\n</code></pre>"},{"location":"usage/generating/","title":"Generating netlists","text":""},{"location":"usage/generating/#cli","title":"CLI","text":"<p>Use <code>cb_netlist.py</code> to generate a netlist from an example:</p> <pre><code>python cb_netlist.py sw130 circuitbrew.examples.inv hspice all\n</code></pre> <p>The general arguments are:</p> <ul> <li><code>techfile</code>:  only Skywater 130 is publicly released, although it's trivial to write your own</li> <li><code>module</code>: Module that will be instanced </li> <li><code>output format</code>: Only <code>hspice</code> for now, although verilog is planned</li> <li><code>flow steps</code>: Only <code>all</code> for now.</li> </ul>"},{"location":"usage/generating/#output","title":"Output","text":"<p>The output goes by default into <code>./output</code>.  In this directory you will see all the files required for simulation:</p> <p><pre><code>output/\n   top.sp\n   hspice_clk.va\n   template_0_hspice_src.va\n   template_0_hspice_bucket.va\n</code></pre> You can run <code>hspice top.sp</code> (or finesim or whatever your simulator of choice is).</p>"},{"location":"usage/reference/","title":"Reference","text":"<p>The examples in the previous section has some details on useful built-in modules in CircuitBrew to help you build and generate stimuli for your circuit. This page is a comprehensive list on the gates and environment modules provided, with links to the API, if you need more information on how to use them or extend them.</p>"},{"location":"usage/reference/#built-in-circuit-modules","title":"Built-in circuit modules","text":"Module Description circuitbrew.gates.Inv Inverter circuitbrew.gates.NorN N-input NOR circuitbrew.qdi.Celement2 2-input c-element circuitbrew.qdi.Wchb 1-bit 4-phase half buffer"},{"location":"usage/reference/#environent-modules","title":"Environent modules","text":"<p>These modules are useful for setting up a simulation environment to generate input stimuli and output verification during a SPICE simulation. Most of these are covered in the different examples.</p> Module Description circuitbrew.elements.VoltageSource Voltage source (usually easier to use Supply) circuitbrew.elements.Supply Vdd and GND sources circuitbrew.elements.ResetPulse Step waveform useful for applying resets circuitbrew.elements.VerilogClock Generate clocks using a Verilog-A instance circuitbrew.elements.VerilogSrc 1-bit Verilog-A source for input vectors circuitbrew.elements.VerilogBucket 1-bit Verilog-A sink/verification for output vectors circuitbrew.qdi.VerilogSrcE1of2 1-bit dual-rail w/ enable Verilog-A source for input vectors circuitbrew.qdi.VerilogBucketE1of2 1-bit dual-rail w/ enable Verilog-A sink/verification for output vectors"},{"location":"usage/techfiles/","title":"Techfile Files","text":"<p>Techfiles are typically found in <code>circuitbrew/tech/process</code>.  Each process node should be a subdirectory here, with two files like the following for Skywater:</p> <pre><code>    circuitbrew/\n        tech/\n            process/\n                sw130/\n                    sw130.sp\n                    tech.yml\n</code></pre> <p>The <code>sw130.sp</code> file is the main SPICE template that's written using Jinja.  The process parameters are specified in <code>tech.yml</code>:</p> <p><pre><code>tech: sw130\nvoltage: 1.8\ntemp: 85\noutput_dir: 'output'\ntemplate: 'sw130.sp'\nFet:\nauto:\nl: 0.5    # Length\nw:  1.0   # Default width\nvt: lvt   # Default vt \nwidth_id: w  # Name in spice xtor model for width/nfin/etc\nPfet:\nauto:\n# Define xtor models for different VTs\nlvt: sky130_fd_pr__pfet_01v8_lvt\nNfet:\nauto:\n# Define xtor models for different VTs\nlvt: sky130_fd_pr__nfet_01v8_lvt\n</code></pre> This tech file is loaded at start up and stored in every <code>Module</code> instance as a dict:  <code>self.sim_setup</code>. In addition, everything is accessible inside your SPICE template file, so if you wanted to add a configuration setting/value pair into your SPICE file, you could just add it to the top-level of the <code>tech.yml</code> file.  Then,  write it into your <code>sw130.sp</code> file with Jinja syntax (e.g. <code>${new_option}</code>)</p> <p>The keys that are named after Module names are meant to provide a way to get  configuration settings to specific classes. Anything that is under the <code>auto</code> key is automatically set as a member attributes for the matching class's objects.  For example, every <code>Fet</code> module object automatically has the <code>l</code>, <code>w</code>, <code>vt</code>, and <code>width_id</code> member attributes set. These can also be overridden via keyword args to the constructor.</p> <p>So, doing the following will create a Fet with width 2.0 while keeping the length as 0.5: <pre><code>    ...\nself.mynfet = Nfet(w=3)\n</code></pre></p> <p>Make sure you follow the class hierarchy in the <code>tech.yaml</code> file if you want the attributes to apply properly.</p>"},{"location":"usage/writing/","title":"Describing circuits","text":"<p>There are several examples that will walk you through how to describe circuits.</p> Example Description Inverter Introduction to concepts via an inverter Inverter with model Test vector generation using models Two-input NOR Multi-bit data and CMOS stack inference QDI buffer huilding and simulating more complex circuits"},{"location":"usage/examples/inverter/","title":"Building an inverter","text":""},{"location":"usage/examples/inverter/#subclass-module-and-define-ports","title":"Subclass Module and define Ports","text":"<p>The first thing to do is define a new class that corresponds to the inverter and define its ports.</p> <p>Every class in CircuitBrew that emits a SPICE subcircuit must inherit from the 'Module' class.  To add single bit ports, you specify class attributes that are instances of 'InputPort' and 'OutputPort'.</p> inverter_01.py<pre><code>from circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\n</code></pre>"},{"location":"usage/examples/inverter/#add-supply-ports-for-powerground","title":"Add supply ports for power/ground","text":"<p>We typically always want to add in power and ground connections, so we'll add a special port called a 'SupplyPort' to  the ports list:</p> inverter_02.py<pre><code>from circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\n</code></pre> <p>A SupplyPort is an example of a CompoundPort, and is defined as:</p> <p><pre><code>class SupplyPort(CompoundPort):\nvdd = Port()\ngnd = Port()\n</code></pre> CompoundPorts are used when you want to pass around pre-defined collections of ports, and the sub-ports can be accessed via standard Python dotted notation (e.g. <code>p.vdd</code>).</p>"},{"location":"usage/examples/inverter/#create-the-transistors-inside-the-inverter","title":"Create the transistors inside the inverter","text":"<p>The next step is to instance whatever circuit elements we want to use inside the inverter. We do this inside a instance method called <code>build</code> which is executed at netlist creation time. Any circuit module or leaf cell that is attached to the Module as an instance attribute (<code>self.*</code>) will be emitted in the final SPICE output. </p> inverter_03.py<pre><code>from circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.fets import Nfet, Pfet\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.a, d=vdd, s=self.b, b=vdd)\nself.ndn = Nfet(g=self.a, d=self.b, s=gnd, b=gnd)\nself.finalize()\n</code></pre> <ol> <li>We have two transistors instanced, a Pfet and Nfet.  In order to get them to emit, we need to attach them  to instance attributes as <code>self.pup</code> and <code>self.ndn</code> (choose whatever names you wish)</li> <li>We connect the gate, drain, source, and bulk to the appropriate nodes. Note that all the ports are also available as instance attributes </li> <li>The widths and lengths are whatever the defaults are in the techfile.</li> <li>We can create local vars to simplify long expressions names, for example, with the vdd and gnd connections.  </li> <li>It's also important to end every <code>build</code> method with the <code>self.finalize()</code> call.  An error will be thrown if you forget this.</li> </ol>"},{"location":"usage/examples/inverter/#add-a-main-module-for-generating-a-netlist","title":"Add a Main Module for generating a netlist","text":"<p>In order to netlist the inverter, we need to have special <code>Main</code> class defined.  CircuitBrew uses this as the starting point for tracing the hierarchy for emitting a netlist:</p> inverter_04.py<pre><code>from circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.fets import Nfet, Pfet\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.a, d=vdd, s=self.b, b=vdd)\nself.ndn = Nfet(g=self.a, d=self.b, s=gnd, b=gnd)\nself.finalize()\nclass Main(Module):\ndef build(self):\nself.inv = Inverter('myinv')\nself.finalize()\n</code></pre>"},{"location":"usage/examples/inverter/#emitting-the-netlist","title":"Emitting the netlist","text":"<p>Assuming your Inverter file is inside <code>circuitbrew/examples/inverter/</code>, we can  run the following to emit the spice netlist:</p> <pre><code>python cb_netlist.py sw130 circuitbrew.examples.inverter.inverter_04 hspice all\n</code></pre>"},{"location":"usage/examples/inverter/#adding-stimuli-to-exercise-the-inverter","title":"Adding stimuli to exercise the inverter","text":"<p>We can add test fixtures like clock signals, pulses, vectors, etc to the circuit,  in order to do transient simulations in HSPICE.  You can import a <code>Supply</code> module for the voltage source from the Elements module, and also a Verilog-A based clock generator for the data input:</p> inverter_05.py<pre><code>from circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.fets import Nfet, Pfet\nfrom circuitbrew.elements import Supply, VerilogClock\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.a, d=vdd, s=self.b, b=vdd)\nself.ndn = Nfet(g=self.a, d=self.b, s=gnd, b=gnd)\nself.finalize()\nclass Main(Module):\ndef build(self):\n# Voltage supply\nself.supply = Supply(name='vdd', voltage=self.sim_setup['voltage'])\np = self.supply.p\nvdd, gnd = p.vdd, p.gnd\n# Create a clock signal to act as input to inverter\nself.clk_gen = VerilogClock('clk', freq=300e3, enable=vdd)\ninv_in = self.clk_gen.clk\nself.inv = Inverter('myinv', a=inv_in, p=p)\nself.finalize()\n</code></pre> <p>This will then emit the following spice:</p> <pre><code>*\n.option brief=1\n.lib \"/Users/virantha/dev/circuitbrew/skywater-pdk-libs-sky130_fd_pr/models/sky130.lib.spice\" tt\n.option brief=0\n.option scale=1e-6\n.temp 85\n.param voltage=1.8\n.option post\n.subckt Main xclk p.vdd inv_in VerilogClock freq=300000.0 offset=0\nxmyinv inv_in b_0 gnd p.vdd Inverter\nxvdd gnd p.vdd Supply\n.ends\n.subckt Supply p.gnd p.vdd\nVvdd_vss p.gnd 0 0.0\nVvdd_vdd p.vdd 0 1.8\n.ends\n.hdl hspice_clk.va\n.subckt Inverter a b p.gnd p.vdd\nxmn0 b a p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 p.vdd a b p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\n.ends\nxmain Main\n.tran 1p 10n\n.end\n</code></pre>"},{"location":"usage/examples/inverter/#next-steps","title":"Next steps","text":"<p>Now that we've covered the basics on assembling and providing a basic stimuli to circuits, let's  move on to move advanced test vector generation in the next example.</p>"},{"location":"usage/examples/inverter_sim/","title":"Adding a behavioral model","text":""},{"location":"usage/examples/inverter_sim/#output-verification-for-an-inverter","title":"Output verification for an inverter","text":"<p>Let's add some test vector checking to the inverter example.</p>"},{"location":"usage/examples/inverter_sim/#generating-values","title":"Generating values","text":"<p>We'll first change the <code>Main</code> module from using a clock as the input to the inverter, to a digital source that can provide a pre-determined sequence of values.  This 'VerilogSrc' is shown below:</p> inverter_sim_01.py<pre><code>from random import randint\nfrom circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.fets import Nfet, Pfet\nfrom circuitbrew.elements import Supply, VerilogClock, VerilogSrc\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.a, d=vdd, s=self.b, b=vdd)\nself.ndn = Nfet(g=self.a, d=self.b, s=gnd, b=gnd)\nself.finalize()\nclass Main(Module):\ndef build(self):\n# Voltage supply\nself.supply = Supply(name='vdd', voltage=self.sim_setup['voltage'])\np = self.supply.p\nvdd, gnd = p.vdd, p.gnd\n# Change the clock to drive the VerilogSrc instead of the Inverter\nself.clk_gen = VerilogClock('clk', freq=300e3, enable=vdd)\n# Sequence of input test vectors on output node 'd'\nself.src = VerilogSrc('src', [randint(0,1) for i in range(10)], \nclk=self.clk_gen.clk, _reset=vdd)\ninv_in = self.src.d\nself.inv = Inverter('myinv', a=inv_in, p=p)\nself.finalize()\n</code></pre> <p>The source module can take a list of values that it loops through and repeats during simulation.  In this example, we generate a vector of 10 1-bit values to source.</p> <p>The waveform of this simulation is below.  The top waveform is the source clock, and then below  is the input and output of the inverter.</p> <p></p>"},{"location":"usage/examples/inverter_sim/#checking-the-values","title":"Checking the values","text":"<p>Checking the expected values can be done using a 'VerilogBucket'. We provide the expected values list to the bucket by inverting the randomly generated list supplied to the <code>VerilogSrc</code>:</p> inverter_sim_02.py<pre><code>from random import randint\nfrom circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.fets import Nfet, Pfet\nfrom circuitbrew.elements import Supply, VerilogClock, VerilogSrc, VerilogBucket\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.a, d=vdd, s=self.b, b=vdd)\nself.ndn = Nfet(g=self.a, d=self.b, s=gnd, b=gnd)\nself.finalize()\nclass Main(Module):\ndef build(self):\n# Voltage supply\nself.supply = Supply(name='vdd', voltage=self.sim_setup['voltage'])\np = self.supply.p\nvdd, gnd = p.vdd, p.gnd\n# Change the clock to drive the VerilogSrc instead of the Inverter\nself.clk_gen = VerilogClock('clk', freq=300e3, enable=vdd)\n# Sequence of input test vectors on output node 'd'\nvals = [randint(0,1) for i in range(10)]\nself.src = VerilogSrc('src', values=vals,\nclk=self.clk_gen.clk, _reset=vdd)\ninv_in = self.src.d\nself.inv = Inverter('myinv', a=inv_in, p=p)\n# Expected values (invert the vals list)\nexpected = [1-v for v in vals]\n# A sampling clock for checking expected output of the inverter\nself.clk_buc = VerilogClock('clk_buc', freq=300e3, offset='100p', enable=vdd)\nself.bucket = VerilogBucket(name='buc', values=expected,\nclk=self.clk_buc.clk, _reset=vdd, d=self.inv.b)\nself.finalize()\n</code></pre> <p>If you then look at the Verilog-A output file (<code>top.valog</code> if you're using hspice), you will see the following output:</p> <pre><code>At time  1.78 ns verified 0th value 0 to test.dat\nAt time  5.11 ns verified 1th value 1 to test.dat\nAt time  8.44 ns verified 2th value 1 to test.dat\nAt time 11.78 ns verified 3th value 1 to test.dat\nAt time 15.11 ns verified 4th value 1 to test.dat\nAt time 18.44 ns verified 5th value 0 to test.dat\nAt time 21.78 ns verified 6th value 1 to test.dat\nAt time 25.11 ns verified 7th value 1 to test.dat\nAt time 28.44 ns verified 8th value 0 to test.dat\n</code></pre>"},{"location":"usage/examples/inverter_sim/#using-model-simulation-to-generate-expected-vectors","title":"Using model simulation to generate expected vectors","text":"<p>While providing the expected values for a simple test case like this is trivial, the real power of CircuitBrew lies in the ability to generate expected vectors from complex circuits that instance multiple blocks.</p> <p>To do this, CircuitBrew has a simple yet powerful discrete-event-simulation framework built in to it. If you provide a method to implement a simulation model for each Module, then it will execute the complete system model for your circuit instanced in <code>Main</code> and generate the output values for each port.  Assuming your model is correct, then you can seamlessly use these output values as the expected values provided to the HSPICE simulation.</p> <p>For this particular example, we only need to provide a simulation model for the inverter, via an async <code>sim</code> method.</p> inverter_sim_03.py<pre><code>from random import randint\nfrom circuitbrew.module import Module\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.fets import Nfet, Pfet\nfrom circuitbrew.elements import Supply, VerilogClock, VerilogSrc, VerilogBucket\nclass Inverter(Module):\na = InputPort()\nb = OutputPort()\np = SupplyPort()\ndef build(self):\nvdd, gnd = self.p.vdd, self.p.gnd\nself.pup = Pfet(g=self.a, d=vdd, s=self.b, b=vdd)\nself.ndn = Nfet(g=self.a, d=self.b, s=gnd, b=gnd)\nself.finalize()\nasync def sim(self):\nwhile True:\nval = await self.a.recv()\nawait self.b.send(1-val)\nclass Main(Module):\ndef build(self):\n# Voltage supply\nself.supply = Supply(name='vdd', voltage=self.sim_setup['voltage'])\np = self.supply.p\nvdd, gnd = p.vdd, p.gnd\n# Change the clock to drive the VerilogSrc instead of the Inverter\nself.clk_gen = VerilogClock('clk', freq=300e3, enable=vdd)\n# Sequence of input test vectors on output node 'd'\nvals = [randint(0,1) for i in range(10)]\nself.src = VerilogSrc('src', values=vals,\nclk=self.clk_gen.clk, _reset=vdd)\ninv_in = self.src.d\nself.inv = Inverter('myinv', a=inv_in, p=p)\n# A sampling clock for checking expected output of the inverter\nself.clk_buc = VerilogClock('clk_buc', freq=300e3, offset='100p', enable=vdd)\nself.bucket = VerilogBucket(name='buc', # values=expected, no longer needed \nclk=self.clk_buc.clk, _reset=vdd, d=self.inv.b)\nself.finalize()\n</code></pre> <p>While we'll delve into more detail on how model simulation works in a different section, in general, every port has a <code>recv</code> and <code>send</code> method.  In your <code>sim</code> method for each block all you need to do is:</p> <ul> <li>call <code>await self.INPUTPORT.recv()</code> to receive all the inputs to your port</li> <li>compute the outputs based on the inputs</li> <li>call <code>await self.OUTPUTPORT.send(output_val)</code> on all the output ports to send the computed values</li> <li>repeat </li> </ul> <p>We have to use the Python <code>async</code> keywords because the simulation methods relies on  concurrent event-based simulation libraries for execution of the sim code.  Under the hood, CircuitBrew currently uses the Curio async library,  although this may change in future iterations.</p> <p>For every Module that doesn't provide a <code>sim</code> method, CircuitBrew will execute the default behavior which is to forward all values received on an InputPort to its fanout connections transparently.</p> <p>If you execute this example, it will run the same way in HSPICE as the last example, except you don't generate and provide expected vectors in the <code>Main</code> method.</p> <p>In the next example, we will take a look at a more complicated example.</p>"},{"location":"usage/examples/nor2/","title":"Building a 2-input NOR","text":"<p>This example will explain how to use Ports for multi-bit data.</p>"},{"location":"usage/examples/nor2/#ports","title":"Ports","text":"<p>You can use an circuitbrew.ports.InputPorts to do a two-wide port for the two-input NOR gate:</p> <pre><code>class Nor2(Module):\na = InputPorts(width=2)\nb = OutputPort()\np = SupplyPort()\n</code></pre> <p>Now, we can access each bit in <code>a</code> as a Python list (<code>self.a[0], self.a[1]</code>).</p>"},{"location":"usage/examples/nor2/#implementation-using-logic-operators","title":"Implementation using logic operators","text":"<p>When you want to implement a CMOS stack that's more than just an inverter, it can quickly become tedious to write out all the transistors and their connections manually.  </p> <p>CircuitBrew allows you to use Python logical operators to quickly construct transistor pull-up and pull-down networks with minimal text:</p> <pre><code>    def build(self):\npdn = self.a[0] | self.a[1]\npup = ~self.a[0]&amp;~self.a[1]\nself.nor = self.make_stacks(output=self.b, pdn=pdn, pup=pup, power=self.p)\nself.finalize() \n</code></pre> <p>Here, we define the pull-up and pull-down stacks following these rules:</p> <ul> <li>Use Python OR <code>|</code> and AND <code>&amp;</code> operators on ports to build the logic.</li> <li>All pull-down stacks (nfets) must have non-negated ports in the logical expression</li> <li>All pull-up stacks (pfets) must have negated ports in the logical expression</li> </ul> <p>Finally, call circuitbrew.module.make_stacks to construct the Fets and return a list of the transistors.</p>"},{"location":"usage/examples/wchb/","title":"QDI Buffer - A More complicated example","text":""},{"location":"usage/examples/wchb/#introduction","title":"Introduction","text":"<p>In this example we will generate an asynchronous circuit built using pipelined  4-phase handshake circuits that are quasi-delay-insensitive (QDI).</p>"},{"location":"usage/examples/wchb/#communication-protocol","title":"Communication protocol","text":"<p>In our example, two buffers communicating a 1-bit data value using a 4-phase handshake will use a bundle of three wires consisting of:</p> <ul> <li>two data rails (a true and false rail) </li> <li>an acknowledge (or enable) wire</li> </ul> <pre><code>flowchart LR\nBUF1-- t --&gt; BUF2\nBUF1-- f --&gt; BUF2\nBUF2-- e --&gt; BUF1</code></pre> <p>We will use return-to-zero signaling on the data wires. So, for example, to send a value of <code>1</code> from BUF1 to BUF2, we would do the following:</p> <pre><code>sequenceDiagram\n    participant BUF1\n    Note right of BUF1: Reset with t,f low and e high\n    BUF1 -&gt;&gt; BUF2: Raise t wire\n    BUF2 --&gt;&gt; BUF1: Lower e wire\n    BUF1 -&gt;&gt; BUF2: Lower t wire\n    BUF2 --&gt;&gt; BUF1: Raise e wire\n    Note right of BUF1: Back at initial state with t,f low and e high</code></pre>"},{"location":"usage/examples/wchb/#circuit-implementation-of-a-buffer","title":"Circuit implementation of a Buffer","text":"<p>We will use a simple implementation of a weak-conditioned-half-buffer(WCHB) handshake circuit to implement BUF1, shown in the schematic below.  The circle with a 'C' represents a Muller Consensus or C-element which is a dynamic gate that sets its output value to the input value when both inputs are the same.  </p> <p></p>"},{"location":"usage/examples/wchb/#building-blocks","title":"Building blocks","text":"<p>First, let's take a look at how we build the individual gates in the WCHB  schematic.</p>"},{"location":"usage/examples/wchb/#parametrized-inverter","title":"Parametrized Inverter","text":"<p>Although we saw a simple inverter previously, this time we're going to show you how to build a parametrized inverter based on its sizes and vt choices.  </p> <p>This inverter is built in to the standard gates library, but let's take a look at the implementation:</p> wchb_inverter.py<pre><code>from circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.ports import InputPort, OutputPort\nfrom circuitbrew.fets import Nfet, Pfet\nfrom circuitbrew.module import Module, Parameterize, Param\nclass Inv(Module):\ninp = InputPort()\nout = OutputPort()\np = SupplyPort()\nn_strength : Param\np_strength : Param\nvt         : Param\ndef build(self):\nself.pup = Pfet(w=self.p_strength, vt=self.vt,\ng=self.inp, d=self.p.vdd, s=self.out, b=self.p.vdd)\nself.ndn = Nfet(w=self.n_strength, vt=self.vt,\ng=self.inp, d=self.p.gnd, s=self.out, b=self.p.gnd)\nself.finalize()\nasync def sim(self):\nwhile True:\nval = await self.inp.recv()\nawait self.out.send(1-val)\nclass Main(Module):\ndef build(self):\nInv_x3 = Parameterize(Inv, p_strength=3, n_strength=3, vt='svt')\nself.inv = Inv_x3()\nself.finalize()\n</code></pre> <p>Adding parameters to a Module is done in the following way:</p> <ul> <li>Add each parameter as a type annotation (Param)</li> <li>Use the parameters as a regular Python attribute in your <code>build</code> method</li> </ul> <p>When you want to use the parametrized Module, you call <code>Parametrize</code> on the  Module you want with the parameter values, which will return a new Module (class) that you can then instance.  If you don't want to keep around the parametrized class for more instances, you could also simply do:</p> <pre><code>    self.inv = Parameterize(Inv, p_strength=3, n_strength=3, vt='svt')()\n</code></pre>"},{"location":"usage/examples/wchb/#parametrized-nor","title":"Parametrized NOR","text":"<p>Now let's take a look at a different use for parameters: Specifying the width of a port. </p> <p>We've already seen how to do a 2-input NOR, but what if we want to build a generic N-input NOR?  Well, we need to first declare N as a Param.  But how do we pass this into the InputPorts as the width, since it hasn't been defined yet?  The way we do this is by using Param as a placeholder function with the name of the parameter:</p> wchb_nor2_01.py<pre><code>class NorN(Module):\nN: Param\na = InputPorts(width=Param('N'))\nb = OutputPort()\np = SupplyPort()\n</code></pre> <p>Once Parameterize is called with the actual value for <code>N</code>, it will resolve itself when <code>a</code> is accessed for the first time.  The rest of the implementation of NorN just needs to use <code>self.N</code> in an appropriate way to build the circuit like so:</p> wchb_nor2_02.py<pre><code>from circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.ports import InputPorts, OutputPort\nfrom circuitbrew.module import Module, Parameterize, Param\nclass NorN(Module):\nN: Param\nsize: Param\na = InputPorts(width=Param('N'))\nb = OutputPort()\np = SupplyPort()\ndef build(self):\np = self.p\nN = self.N\npdn = self.a[0]\npup = ~self.a[0]\nfor i in range(1,N):\npdn |= self.a[i]\npup &amp;= ~self.a[i]\nself.nor = self.make_stacks(output=self.b, \npdn=pdn, pup=pup, power=p,\nwidth=self.size)\nself.finalize()\nclass Main(Module):\ndef build(self):\nNor3 = Parameterize(NorN, N=3, size=2)\nself.nor3 = Nor3()\nself.finalize()\n</code></pre> <p>Here, you can see how we used the <code>|</code> and <code>&amp;</code> operators in a loop to construct the CMOS stacks.</p> <p>The resulting SPICE looks like </p> <pre><code>.subckt Main xNorN_N_3_size_2_inst_0 a_0 a_1 a_2 b_3 p_4 p_5 NorN_N_3_size_2\n.ends\n.subckt NorN_N_3_size_2 a[0] a[1] a[2] b p.gnd p.vdd\nxmn0 b a[1] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=2 l=0.5\nxmn1 b a[0] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=2 l=0.5\nxmn2 b a[2] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=2 l=0.5\nxmp0 d_0 a[0] b p.vdd sky130_fd_pr__pfet_01v8_lvt w=2 l=0.5\nxmp1 d_1 a[1] d_0 p.vdd sky130_fd_pr__pfet_01v8_lvt w=2 l=0.5\nxmp2 p.vdd a[2] d_1 p.vdd sky130_fd_pr__pfet_01v8_lvt w=2 l=0.5\n.ends\n</code></pre> <p>Notice that the parameterized Nor sub-circuit has its parameter values inserted into the name.  If another Nor is parameterized (say with N=4), then it will have a different sub-circuit definition with <code>N_4</code> in the name.</p>"},{"location":"usage/examples/wchb/#c-element","title":"C-element","text":"<p>The c-element will be a state-holding gate, with the pull-up and pull-down both just having the two terms in series.  We will use combinational feedback to maintain the output when the inputs disagree in value.</p> wchb_c2_01.py<pre><code>from circuitbrew.compound_ports import SupplyPort\nfrom circuitbrew.ports import InputPorts, OutputPort\nfrom circuitbrew.module import Module, Parameterize, Param\nfrom .wchb_inverter_01 import Inv\nclass Celement2(Module):\ni = InputPorts(width=2)\no = OutputPort()\np = SupplyPort()\ndef build(self):\np = self.p\n# Let's constnnruct this using combination feedback\npdn = self.i[0] &amp; self.i[1]\npup = ~self.i[0] &amp; ~self.i[1]\nself.inv = Parameterize(Inv, n_strength=2, p_strength=2, vt='lvt')(out = self.o, p = p)\n_o = self.inv.inp\ncf_pdn = self.o &amp; (self.i[0] | self.i[1])\ncf_pup = ~self.o &amp; (~self.i[0] | ~self.i[1])\nself.celem = self.make_stacks(output=_o, pdn=pdn, pup=pup, power=p)\nself.cf    = self.make_stacks(output=_o, pdn=cf_pdn, pup=cf_pup, power=p)\nself.finalize()\nclass Main(Module):\ndef build(self):\nself.c2 = Celement2()\nself.finalize()\n</code></pre>"},{"location":"usage/examples/wchb/#putting-it-all-together","title":"Putting it all together","text":""},{"location":"usage/examples/wchb/#assembling-the-wchb","title":"Assembling the WCHB","text":"<p>Let's construct the full WCHB circuit, with all of these building blocks.</p> wchb_01.py <pre><code>from random import randint\nfrom circuitbrew.module import Module, Parameterize\nfrom circuitbrew.ports import InputPort\nfrom circuitbrew.compound_ports import SupplyPort, E1of2InputPort, E1of2OutputPort\nfrom circuitbrew.gates import NorN\nfrom circuitbrew.gates import Inv_x1 as Inv\nfrom circuitbrew.qdi import Celement2\nclass Wchb(Module):\nl = E1of2InputPort()\nr = E1of2OutputPort()\n_pReset = InputPort()\np = SupplyPort()\ndef build(self):\nself.c2_t = Celement2(i=[self.l.t, self.r.e], o = self.r.t, p=self.p)\nself.c2_f = Celement2(i=[self.l.f, self.r.e], o = self.r.f, p=self.p)\nself.inv_mypreset = Inv(inp=self._pReset, p=self.p)\nmypreset = self.inv_mypreset.out\nself.nor = Parameterize(NorN, N=3)(a=[self.r.t, self.r.f, mypreset], \nb=self.l.e, p=self.p)\nself.finalize()\nasync def sim(self):\nwhile True:\nval = await self.l.recv()\nawait self.r.send(val)\n</code></pre> <p>We have added a reset signal to the schematic, just to make sure this circuit resets  to a known state in the handshake. The simulation method is quite straightforward, since it's just a pipelined buffer.</p>"},{"location":"usage/examples/wchb/#buffer-chain","title":"Buffer chain","text":"<p>For the SPICE simulation, we're going to build a parameterized chain of buffers. We will also use <code>src</code> and <code>bucket</code> modules that can drive <code>e1of2</code> ports.</p> <pre><code>graph LR\n    src --&gt; buf_0;\n    buf_0 --&gt; buf_1;\n    buf_1 --&gt; buf_2;\n    buf_2 --&gt; buf_3;\n    buf_3 --&gt; bucket;\n</code></pre> wchb_02.py <pre><code>from random import randint\nfrom circuitbrew.module import Module\nfrom circuitbrew.elements import Supply, ResetPulse\nfrom circuitbrew.qdi import Wchb, VerilogBucketE1of2, VerilogSrcE1of2\nclass Main(Module):\ndef build(self):\nself.supply = Supply('vdd', self.sim_setup['voltage'], \nmeasure=True )\nself.p = self.supply.p\np = self.supply.p\nself._preset_pulse = ResetPulse('preset', p=p)\nself._sreset_pulse = ResetPulse('sreset', p=p)\n_pR = self._preset_pulse.node\n# Set up a chain of wchbs\nN = 4\nself.buf = [ Wchb(f'wchb_{i}', _pReset=_pR, p=p)\nfor i in range(N)\n]\n# Connect the wchbs\nfor i in range(1,N):\nself.buf[i].l = self.buf[i-1].r\n_sR = self._sreset_pulse.node\nl = self.buf[0].l\nr = self.buf[N-1].r\nself.src = VerilogSrcE1of2(\nname = 'src', values=[randint(0,1) for i in range(10)],\n_pReset=_pR, _sReset= _sR)\nself.src.l = self.buf[0].l\nself.buc = VerilogBucketE1of2(\nname='buc',\n_pReset=_pR, _sReset=self._sreset_pulse.node, l=r)\nself.finalize()\n</code></pre> <p>It becomes quite simple to build complex SPICE structures in CircuitBrew with Python's powerful syntax; here, we're instantiating a chain of buffers in a <code>for</code> loop and connecting them in a generic way.</p> <p>The generated SPICE file is shown below:</p> wchb_02.sp <pre><code>*\n.option brief=1\n.lib \"/Users/virantha/dev/circuitbrew/skywater-pdk-libs-sky130_fd_pr/models/sky130.lib.spice\" tt\n.option brief=0\n.option scale=1e-6\n*---------------------------------------\n.temp 85\n.param voltage=1.8\n.option post\n.subckt Main Vpwlpreset _pR p.gnd PWL (0n 0 4n 0 4.5n 1.8)\nVpwlsreset _sR p.gnd PWL (0n 0 4n 0 4.5n 1.8)\nxbuc _pR _sR r.t r.f r.e VerilogBucketE1of2_0\nxwchb_0 _pR l.t l.f l.e p.vdd p.gnd r_0 r_1 r_2 Wchb\nxwchb_1 _pR r_0 r_1 r_2 p.vdd p.gnd r_3 r_4 r_5 Wchb\nxwchb_2 _pR r_3 r_4 r_5 p.vdd p.gnd r_6 r_7 r_8 Wchb\nxwchb_3 _pR r_6 r_7 r_8 p.vdd p.gnd r.t r.f r.e Wchb\nxsrc _pR _sR l.t l.f l.e VerilogSrcE1of2_0\nxvdd p.vdd p.gnd Supply\n.ends\n.subckt Supply p.vdd p.gnd\n.measure TRAN supplycurrent0 avg i(Vvdd_vdd)  .measure TRAN supplypower0 PARAM='-supplycurrent0*1.8'\n.measure TRAN supplypower_direct0 AVG P(Vvdd_vdd)  Vvdd_vss p.gnd 0 0.0\nVvdd_vdd p.vdd 0 1.8\n.ends\n.subckt Wchb _pReset l.t l.f l.e p.vdd p.gnd r.t r.f r.e\nxCelement2_inst_1 l.f r.e r.f p.vdd p.gnd Celement2\nxCelement2_inst_0 l.t r.e r.t p.vdd p.gnd Celement2\nxInv_p_strength_1_n_strength_1_vt_svt_inst_0 _pReset mypreset p.vdd p.gnd Inv_p_strength_1_n_strength_1_vt_svt\nxNor3_inst_0 r.t r.f mypreset l.e p.vdd p.gnd Nor3\n.ends\n.subckt Celement2 i[0] i[1] o p.vdd p.gnd\nxmn0 t228_0 i[0] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmn1 _o i[1] t228_0 p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 d_0 i[0] _o p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxmp1 p.vdd i[1] d_0 p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxmn2 t255_0 i[1] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmn3 d_1 i[0] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmn4 _o o t255_0 p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp2 d_2 o _o p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxmp3 d_3 i[0] d_2 p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxmp4 p.vdd i[1] s_4 p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxInv_p_strength_1_n_strength_1_vt_svt_inst_1 _o o p.vdd p.gnd Inv_p_strength_1_n_strength_1_vt_svt\n.ends\n.subckt Inv_p_strength_1_n_strength_1_vt_svt inp out p.vdd p.gnd\nxmn0 p.gnd inp out p.gnd sky130_fd_pr__nfet_01v8_lvt w=1 l=0.5\nxmp0 p.vdd inp out p.vdd sky130_fd_pr__pfet_01v8_lvt w=1 l=0.5\n.ends\n.subckt Nor3 a[0] a[1] a[2] b p.vdd p.gnd\nxmn0 b a[1] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmn1 b a[0] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmn2 b a[2] p.gnd p.gnd sky130_fd_pr__nfet_01v8_lvt w=1.0 l=0.5\nxmp0 d_0 a[0] b p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxmp1 d_1 a[1] d_0 p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\nxmp2 p.vdd a[2] d_1 p.vdd sky130_fd_pr__pfet_01v8_lvt w=1.0 l=0.5\n.ends\n.hdl template_0_hspice_src_1of2.va\n.hdl template_0_hspice_bucket_1of2.va\nxmain Main\n.tran 1p 10n\n.end\n</code></pre> <p>The waveforms from the resulting simulation are shown below, with the <code>l.t</code> and <code>l.f</code> input rails and the shifted versions <code>r.t</code> and <code>r.f</code> at the end of the chain of buffers. </p>"}]}